

  
Titre : Algorithmique et méthodes de programmation 1 
	Logique  de conception des programmes 
Objectifs du cours
Le présent cours vise à initier l’étudiante ou l’étudiant aux notions d’algorithmique et méthodes de programmation.
Ce cours se range dans l'émergence et la popularité subséquente de l’algorithmique et programmation qui ont provoqué l'avènement des logiciels informatiques. Il s’octroie le privilège d’initier les apprenants sur l’algorithme informatique et la programmation en Pascal.
A sa fin, l’apprenant sera d’abord capable de de connaître  les différents types des symboles utilisés pour décrire un ordinogramme informatique ainsi que la norme qui régit ses symboles; ensuite, l’apprenant sera  initié à la traduction sous forme algorithmique et/ou en pseudo code, un problème de programmation; il sera invité, pour pratiquer plus tard, des (méthodes) règles générales de la programmation structurée, communes à la plupart des langages de programmation (Pascal, C++, C#, etc.) qu'il aura à découvrir tout au long de sa formation au premier et deuxième cycle. Ces règles seront formulées au  niveau de l'entête du programme, des variables, des fonctions et procédures, des structures de contrôle, etc. 
Et enfin l’apprenant sera initié à  l’usage de l’outil pédagogique d’aide à la vérification des algorithmes (Algobox), à la programmation en langage Pascal :L'étudiant  sera d'abord initié  aux  activités  plus  techniques : installation  et  configuration du kit de la programmation (le Dev-Pascal par exemple, ou My Pascal, sous Windows), édition du code source d'un programme  écrit  en  My  Pascal, Dev-Pascal ou Turbo Pascal, compilation du programme, correction des erreurs, exécution du programme, archivage et recherche des fichiers tout en appliquant la syntaxe du  langage Pascal pour pouvoir implémenter les algorithmes classiques en respectant le style de programmation structurée.
Situation dans les programmes 
Le cours de LCP est obligatoire dans le programme de graduat en informatique de gestion et dans le programme de certificat en informatique. Il est habituellement suivi au premier trimestre du programme. 
Ce cours s’adresse : 
• aux étudiantes et aux étudiants de Licence en informatique de Gestion ; 
• aux étudiantes et aux étudiants du graduat en informatique ; 
• aux étudiantes et aux étudiants du certificat en informatique. 
Exercices simples en laboratoire. 
Note : pour bénéficier pleinement de cet enseignement, vous devez avoir accès à : 
Un micro-ordinateur PC 
Préalable : Etre capable de communiquer en français, l’anglais reste un atout, et se sentir à l’aise en faisant les corrections dans le code source. 

 

PREMIERE PARTIE : L’ALGORITHMIQUE
Chapitre premier : Concepts fondamentaux
1.1.	Programmation
La programmation dans le domaine informatique est l'ensemble des activités qui permettent l'écriture des programmes informatiques. C'est une étape importante de la conception de logiciel. 
Pour écrire le résultat de cette activité, on utilise un langage de programmation.
La programmation représente usuellement le codage, c’est-à-dire la rédaction du code source d'un logiciel. On utilise plutôt le terme développement pour dénoter l'ensemble des activités liées à la création d'un logiciel.
1.2.	Programme
En informatique, un programme est une séquence d'instructions qui spécifie étape par étape les opérations à effectuer pour obtenir un résultat. Il est exprimé sous une forme qui permet d'utiliser un ordinateur pour exécuter les instructions. Un programme est la forme électronique d'un algorithme exprimé dans un langage de programmation - un vocabulaire et des règles de ponctuation destinées à exprimer des programmes.
1.2.1.	Programme source 
Un programme source est un ensemble d’opérations telles qu'elles ont été exprimées par un programmeur, souvent dans un langage de programmation de haut niveau, c'est-à-dire dont la notation s'inspire des langues naturelles - le vocabulaire et la ponctuation utilisée sont typiquement inspirés de l'anglais.
1.2.2.	Programme objet ou binaire 
Un programme objet ou binaire est la forme sous laquelle il pourra être exécuté par un ordinateur: une suite de valeurs binaires difficiles à manipuler pour le programmeur, et obtenus par traduction automatique du programme source.
Des programmes sont présents dans tous les appareils informatiques: ordinateur, console de jeu, guichet automatique bancaire. Des programmes sont également présent dans des pièces de matériel informatique ainsi que de nombreux dispositifs électroniques: imprimante, modem, GPS, téléphone mobile, machine à laver, appareil photo numérique, décodeur TV numérique, injection électronique ou pilote automatique.
Le programme décrit de manière exacte les différentes étapes d'un algorithme: ce qu'il y a à faire, quand et avec quelles informations. 
Selon l'architecture de von Neumann crée en 1945, un programme est enregistré dans la mémoire de l'ordinateur, ce qui permet de l'exécuter de manière répétée sans intervention humaine.
1.3.	Langage de programmation
Un langage de programmation est une notation utilisée pour exprimer des algorithmes et les faire exécuter par un ordinateur. Un algorithme est un procédé pour obtenir un résultat par une succession de calculs, décrit sous forme de pictogrammes et de termes simples dans une langue naturelle. Jusqu'en 1950 les programmeurs exprimaient les programmes dans le langage de l'ordinateur, un langage fait de termes bizarres qui rendait le travail pénible et le résultat sujet à de nombreuses erreurs. Dès 1950 les programmes ont été décrit dans un langage différent - un langage de programmation, ce qui rendait les opérations plus simples à exprimer. Le programme était ensuite traduit automatiquement sous une forme qui permet d'être exécuté par l'ordinateur.
Sur demande, l'ordinateur exécutera les instructions du programme. Bien qu'il exécute toujours exactement ce qui est instruit et ne se trompe jamais, il peut arriver que les instructions qu'il exécute soient erronées suite à une erreur humaine lors de l'écriture du programme. Les langages de programmations visent à diminuer le nombre de ces bugs, ils sont cependant inévitables dans des programmes de plusieurs milliers de lignes. 
Un programme de traitement de texte peut être fait de plus de 750 000 lignes de code, et un système d'exploitation peut être fait de plus de 50 millions de lignes. En moyenne un programmeur prépare, écrit, teste et documente environ 20 lignes de programme par jour, et la création de grands programmes est le fait d'équipes et peut nécessiter plusieurs mois voire plusieurs années.
1.4.	Création des programmes
La création de programmes - est un sujet central en informatique. Les instructions qu'un ordinateur devra exécuter doivent pouvoir être exprimées de manière précise et non ambiguë. Pour ce faire, les langages de programmation combinent la lisibilité de l'anglais avec l'exactitude des mathématiques. Les programmes sont créés par des programmeurs, ou des ingénieurs logiciels. La création d'un programme comprend une série d'activités telles que la conception, l'écriture, le test et la documentation. En vue d'obtenir un programme de meilleure qualité, le travail de programmation se fait selon une démarche systématique et planifiée.
Un programme fait généralement partie d'un logiciel: un ensemble qui comporte typiquement plusieurs programmes, ainsi que tout le nécessaire pour permettre leur utilisation: fichiers de données, fichiers de configuration et documentation.
En droit un programme est une œuvre écrite, protégée par le droit d'auteur. Le texte peut paraitre à première vue dénuer de sens, mais apparaitre très clair et informatif pour un lecteur averti. Le droit d'auteur s'applique au programme du moment qu'il est enregistré de manière permanente, même s'il n'existe pas d'édition sur papier. Le droit d'auteur protège autant le programme source - écrit par le programmeur sous une forme formalisée de l'anglais, que le programme binaire - celui traduit sous forme de bits par le compilateur.
1.5.	Vocabulaire de programmation
Le vocabulaire de programmation est un ensemble de règles d'écriture utilisées pour instruire un ordinateur d'effectuer certaines tâches. La plupart des langages de programmation sont dits de haut niveau, c'est-à-dire que leur notation s'inspire des langues naturelles - le vocabulaire et la ponctuation utilisée sont typiquement inspirés de l'anglais.
Le processeur est le composant électronique qui exécute les instructions. Chaque processeur est conçu pour exécuter certaines instructions, dites instructions machine. La palette d'instructions disponibles sur un processeur forme le langage machine. Par exemple le processeur Intel 80486 a une palette de 342 instructions.
Le langage d'assemblage est une représentation textuelle des instructions machine, un langage de bas niveau, qui permet d'exprimer les instructions machines sous une forme symbolique plus facile à manipuler, où il y a une correspondance 1-1 entre les instructions machines et les instructions en langage d'assemblage.
Les langages de programmation de haut niveau permettent d'exprimer des instructions de manière synthétique, en faisant abstraction du langage machine. Par rapport au langage d'assemblage, ils permettent d'exprimer des structures, permettent d'écrire des programmes plus rapidement, avec moins d'instructions, les programmes écrits dans des langages de haut niveau sont plus simples à modifier et portables - ils peuvent fonctionner avec différents processeurs. Cependant un programme exprimé en langage de haut niveau, puis compilé est moins efficace et comporte plus d'instruction que s'il avait été exprimé en langage d'assemblage.
Entre 1950 et 2000, plus de 50 langages de programmation sont apparus. 
Chacun apportait un lot de nouveaux concepts, de raffinements et d'innovations. Jusque dans les années 1950, l'utilisation des langages de programmation était semblable à l'écriture d'instructions machines. L'innovation des années 1960 a été de permettre une notation proche des mathématiques pour écrire des instructions de calcul. Les innovations des années 1970 ont permis l'organisation et l'agrégation des informations manipulées par les programmes - voir structure de données et structure de contrôle. Puis l'arrivée de la notion d'objet a influencé l'évolution des langages de programmation postérieurs à 1980.
La programmation consiste à parcourir le chemin qui va d'une idée - souvent vague - jusqu'à une suite d'instructions précises exécutées par une machine. Les langages de programmation ont été créés dans l'optique de faciliter le travail du programmeur en raccourcissant le chemin qui va de l'idée au code source.
Les programmes sont créés par des programmeurs, ou des ingénieurs logiciels. Les programmeurs travaillent principalement sur l'écriture de programmes tandis que les ingénieurs logiciels travaillent à toutes les étapes de la création du programme. Ils appliquent une démarche formelle et rigoureuse basée sur le génie industriel et les techniques de management.
1.6.	Ecriture d’un programme
Avant de commencer à écrire un programme destiné à résoudre un problème, le programmeur doit déterminer les caractéristiques du problème à résoudre. Ceci se fait en plusieurs étapes indépendantes du langage de programmation utilisé. La technique courante est celle d'un cycle de développement, qui comporte des étapes de définition, de conception, d'écriture, de test, d'installation et de maintenance:
	Le problème est tout d'abord examiné en détail en vue de connaitre l'étendue du programme à créer. l'étape suivante consiste à choisir des solutions et des algorithmes, puis décrire leur logique sous forme de diagrammes, en vue de clarifier le fonctionnement du programme et faciliter son écriture.
	Une fois le programme écrit, celui-ci subit une suite de tests. Les résultats produits par le programme sont comparé avec des résultats obtenus manuellement. De nombreux tests sont nécessaires et les mêmes tests sont exécutés plusieurs fois. Ensuite de quoi le programme est installé dans la machine de l'utilisateur final, qui fera ses premières observations. Le programme sera ensuite modifié en fonction des commentaires fait par l'utilisateur, et des inconvénients qu'il a signalé.
	Les besoins des utilisateurs et des systèmes informatiques varient continuellement, et le programme est régulièrement reconstruit et modifié en vue d'être adapté aux besoins. De nouvelles fonctions y sont ajoutées, et des erreurs qui n'avaient pas été décelées auparavant sont corrigées.
Le but du cycle de développement est de réduire les coûts de fabrication tout en augmentant la qualité du programme. Les qualités recherchées sont l'efficacité, la flexibilité, la fiabilité, la portabilité, et robustesse, il doit également être convivial et facile à modifier:
Il est attendu d'un programme qu'il demande peu d'effort de programmation, que les instructions demandent peu de temps et nécessitent peu de mémoire, qu'il peut être utilisé pour de nombreux usages et donne les résultats attendus quels que soient les changements - permanents ou temporaires - du système informatique.
Il est également attendu qu'il peut être facilement transféré sur un modèle d'ordinateur différent de celui pour lequel il est construit, qu'il produit des résultats probants y compris lorsque les informations entrées sont incorrectes, qu'il peut être facilement compris par un usager novice et que le code source peut être facilement modifié par la suite.
1.7.	Exécution
Des programmes peuvent être exécutés non seulement par les ordinateurs, mais par les nombreux appareils qui sont basés sur des composants informatiques, par exemple certains robots ménagers, téléphones, fax, instruments de mesure, récepteur de télévision, ainsi que les pièces de matériel informatique telles que disque durs, routeurs, imprimantes, les consoles de jeu vidéo, les assistants personnels et les automates bancaires. Contrairement aux ordinateurs, ces appareils ne contiennent souvent pas de système d'exploitation, les programmes sont enregistrés dans l'appareil lors de la fabrication, et la vitesse d'exécution des programmes est souvent d'importance mineure.
Sans contre-indication, les instructions d'un programme sont exécutées une après l'autre, de manière linéaire. Les langages de programmations permettent d'exprimer des alternatives: une suite d'instructions est exécutée uniquement si une condition donnée est remplie, dans le cas contraire une autre suite est exécutée. Les langages de programmation permettent également de faire répéter l'exécution d'une suite d'instruction jusqu'à ce qu'une condition donnée soit remplie.
L'exécution se déroule de manière différente suivant si le langage de programmation s'utilise avec un compilateur ou un interpréteur:
1.7.1.	Compilateur
Un compilateur lit le programme source en entier, et le transforme en instructions machines. La transformation peut se faire en plusieurs étapes et nécessiter plusieurs lectures du programme. Une fois traduit, le programme est enregistré, puis copié en mémoire et exécuté par le processeur tel quel.
1.7.2.	Interpréteur 
Un interpréteur par contre, opère ligne par ligne: lit une ligne de programme source, puis exécute les instructions machines correspondantes. L'avantage d'un interpréteur c'est que les erreurs peuvent être immédiatement corrigées. Le désavantage est que l'exécution du programme est 5 à 25 fois moins rapide que si le programme avait été préalablement traduit et exécuté tel quel.
L'exécution des programmes est basé sur le principe de la machine à programme enregistré, de John von Neumann: Les instructions de programme sont exécutées par un processeur; ce composant électronique exécute chaque instruction de programme par une succession d'opérations charger-décoder-exécuter: l'instruction est tout d'abord copiée depuis la mémoire vers le processeur, elle est ensuite décomposée bit par bit pour déterminer l'opération à effectuer, puis cette opération est exécutée. La plupart des opérations sont d'ordre arithmétique (addition, soustraction), ou logiques. L'exécution de programmes par le processeur central (anglais CPU) contrôle la totalité des opérations effectuées par l'ordinateur.
L'exécution du cycle charger-décoder-exécuter est rythmé par une horloge branchée au processeur. En 2011 la fréquence d'horloge supportée par les processeurs contemporains se compte en mégahertz ou en gigahertz, ce qui corresponds à des millions voire des milliards de cycles par seconde.
Les processeurs contemporains peuvent traiter plusieurs instructions simultanément: lorsqu'une instruction est chargée, le processeur charge immédiatement l'instruction suivante, sans attendre que cette instruction soit décodée puis exécutée, et les processeurs peuvent également charger / décoder / exécuter plusieurs instructions en un seul cycle d'horloge.
Le système d'exploitation est un ensemble de programme qui surveille l'exécution des autres programmes. Il est activé automatiquement lorsque l'ordinateur est mis en marche. Les systèmes d'exploitation contemporains permettent d'exécuter simultanément plusieurs programmes, au service de plusieurs utilisateurs, et en utilisant plusieurs processeurs. Un seul processeur exécute typiquement plusieurs programmes. Dans les faits, le processeur n'exécute qu'un seul programme à la fois à un instant donné, et un programme planificateur (anglais scheduler) du système d'exploitation effectue une rotation, ou régulièrement il interrompt le programme en cours d'exécution, pour exécuter le programme suivant. Le rythme de rotation est cependant tellement rapide qu'il donne l'illusion que les programmes sont exécutés en même temps.
1.8.	Algorithme
Un algorithme est une suite finie et non-ambiguë d’opérations ou d'instructions permettant de résoudre un problème.
Le mot algorithme vient du nom latinisé du mathématicien persan Al-Khawarizmi, surnommé « le père de l'algèbre ». Le domaine qui étudie les algorithmes est appelé l'algorithmique. 
On retrouve aujourd'hui des algorithmes dans de nombreuses applications telles que la cryptographie, le routage d'informations, la planification et l'optimisation de ressources, la bio-informatique, ...
Un algorithme est correct lorsque pour chaque instance, il se termine en produisant la bonne sortie, c'est-à-dire qu'il résout le problème posé. On mesure l'efficacité d'un algorithme notamment par sa durée pour produire le résultat attendu et par sa consommation de mémoire RAM (en partant du principe que chaque instruction a un temps d'exécution constant). Les ordinateurs sur lesquels tournent ces algorithmes ne sont pas infiniment rapides : le temps de machine reste une ressource limitée malgré une augmentation des performances considérable des machines.
Un algorithme sera donc dit performant s'il utilise avec parcimonie les ressources dont il dispose, c'est-à-dire le temps CPU et la mémoire RAM. L’analyse de la complexité algorithmique permet de mesurer ces consommations.
Une recette de cuisine est un algorithme. Elle en contient les éléments constitutifs :
	des entrées (les ingrédients, le matériel utilisé)
	des instructions élémentaires simples, dont l'exécution amène au résultat voulu
	un résultat : le plat préparé.
Cependant, les recettes de cuisine ne sont en général pas présentées rigoureusement sous forme non-ambigüe : il est d'usage d'y employer des termes vagues laissés à l'appréciation du cuisinier alors qu'un algorithme stricto-sensu doit être précis et sans ambigüité à l'exécution.
1.9.	Algorithmique
L'algorithmique est l’ensemble des règles et des techniques qui sont impliquées dans la définition et la conception d'algorithmes, c'est-à-dire de processus systématiques de résolution d'un problème permettant de décrire les étapes vers le résultat. En d'autres termes, un algorithme est une suite finie et non-ambiguë d’instructions permettant de donner la réponse à un problème.
Si les instructions d'un algorithme s’exécutent les unes après les autres, l'algorithme est dit séquentiel, si elles s’exécutent en même temps, il est parallèle. Si l'algorithme exploite des tâches s’exécutant sur un réseau de processeurs on parle d’algorithme réparti, ou distribué.
Les premiers algorithmes dont on a retrouvé des descriptions datent des Babyloniens, au IIIe millénaire av. J. C.. Ils décrivent des méthodes de calcul et des résolutions d'équations à l'aide d'exemples.
Un algorithme célèbre est celui qui se trouve dans le livre 7 des Éléments d'Euclide, et appelé algorithme d'Euclide. Il permet de trouver le plus grand diviseur commun, ou PGCD, de deux nombres. Un point particulièrement remarquable est qu’il contient explicitement une itération et que les propositions 1 et 2 démontrent sa convergence.
Un algorithme énonce une résolution sous la forme d’une série d’opérations à effectuer. La mise en œuvre de l’algorithme consiste en l’écriture de ces opérations dans un langage de programmation et constitue alors la brique de base d’un programme informatique.
Les informaticiens utilisent fréquemment l’anglicisme implémentation pour désigner cette mise en œuvre. L’écriture en langage informatique est aussi fréquemment désignée par le terme « codage », qui n’a ici aucun rapport avec la cryptographie, mais qui se réfère au terme « code source » pour désigner le texte, en langage de programmation, constituant le programme. L’algorithme devra être plus ou moins détaillé selon le niveau d’abstraction du langage utilisé, de même qu'une recette de cuisine doit être plus ou moins détaillée selon l’expérience du cuisinier.
1.9.1.	Étude formelle
De nombreux outils formels ou théories ont été développés pour décrire les algorithmes, les étudier, exprimer leurs qualités, pouvoir les comparer :
	Ainsi, pour décrire les algorithmes, des structures algorithmiques ont été mises en évidence : structures de contrôle et structures de données.
	Pour justifier de la qualité des algorithmes, les notions de correction, de complétude et de terminaison ont été mises en place.
	Enfin, pour comparer les algorithmes, une théorie de la complexité des algorithmes a été définie.
1.9.2.	Structures algorithmiques
Les concepts en œuvre en algorithmique, par exemple selon l'approche de N. Wirth pour les langages les plus répandus (Pascal, C, etc.), sont en petit nombre. Ils appartiennent à deux classes :
1.9.2.1.	Structures de contrôle et structure des données
	Structures de contrôle
	séquences
	conditionnelles
	boucles
	Structures de données
	constantes
	variables
	tableaux
	structures récursives (listes, arbres, graphes)
Ce découpage est parfois difficile à percevoir pour certains langages (Lisp, Prolog, …) plus basés sur la notion de récursivité où certaines structures de contrôle sont implicites et, donc, semblent disparaître.
1.9.2.2.	Correction, complétude, terminaison
Ces trois notions « correction », « complétude », « terminaison » sont liées, et supposent qu'un algorithme est écrit pour résoudre un problème.
La terminaison est l'assurance que l'algorithme terminera en un temps fini. Les preuves de terminaison font habituellement intervenir une fonction entière positive strictement décroissante à chaque « pas » de l'algorithme.
Étant donnée la garantie qu'un algorithme terminera, la preuve de correction doit apporter l'assurance que si l'algorithme termine en donnant une proposition de solution, alors cette solution est correcte - c'est-à-dire qu'elle est effectivement une solution au problème posé.
La preuve de complétude garantit que, pour un espace de problèmes donné, l'algorithme, s'il termine, donnera des propositions de solutions.
1.9.2.3.	Approches pratiques
L'algorithmique a développé quelques stratégies pour résoudre les problèmes :
	algorithme glouton : un premier algorithme peut souvent être proposé en ne regardant que les cas simples, ou ceux apparaissant le plus souvent. On parle alors d'algorithme glouton. L'algorithme glouton n'est souvent qu'une première étape dans la rédaction d'un algorithme plus performant.
	diviser pour régner : pour améliorer les performances des algorithmes, une technique usuelle consiste à diviser les données d'un problème en sous-ensembles de tailles plus petites, jusqu'à obtenir des données que l'algorithme pourra traiter au cas par cas. Une seconde étape dans ces algorithmes consiste à « fusionner » les résultats partiels pour obtenir une solution globale. Ces algorithmes sont souvent associés à la récursivité.
	recherche exhaustive (ou combinatoire) : une méthode utilisant l'énorme puissance de calcul des ordinateurs consiste à regarder tous les cas possibles. Cela n'est pour autant possible que dans certains cas particuliers (la combinatoire est souvent plus forte que l'énorme puissance des ordinateurs, aussi énorme soit-elle)
	aléatoire, ou par approximations successives : certains algorithmes utilisent des recherches aléatoires, ou par approches successives, donnant de meilleurs résultats (en moyenne) que des recherches directes ou explicites.
	décomposition top-down / bottom-up : les décompositions top-bottom consistent à essayer de décomposer le problème en sous-problèmes à résoudre successivement, la décomposition allant jusqu'à des problèmes triviaux faciles à résoudre. L'algorithme global est alors donné par la composée des algorithmes définis au cours de la décomposition. La démarche bottom-up est la démarche inverse, elle consiste à partir d'algorithmes simples, ne résolvant qu'une étape du problème, pour essayer de les composer pour obtenir un algorithme global.
	pré-traitement / post-traitement : parfois, certains algorithmes comportent une ou deux phases identifiées comme des prétraitements (à faire avant l'algorithme principal), ou post-traitement (à faire après l'algorithme principal), pour simplifier l'écriture de l'algorithme général.
1.9.3.	Exemples d’algorithmes, de problèmes, d'applications ou domaines d'application
Il existe un certain nombre d’algorithmes classiques, utilisés pour résoudre des problèmes ou plus simplement pour illustrer des méthodes de programmation. On se référera aux articles suivants pour de plus amples détails :
	Algorithmes ou problèmes classiques (du plus simple ou plus complexe)
	échange, ou comment échanger les valeurs de deux variables : problème classique illustrant la notion de variable informatique.
	Algorithmes de recherche, ou comment retrouver une information dans un ensemble structuré ou non (par exemple Recherche dichotomique)
	algorithme de tri, ou comment trier un ensemble de nombres le plus rapidement possible ou en utilisant le moins de ressources possible
	problème du voyageur de commerce, problème du sac à dos, problème SAT et autres algorithmes ou approximations de solutions pour les problèmes combinatoires difficiles (dit NP-complets)
	Algorithmes ou problèmes illustrant la programmation.
	tours de Hanoï
	huit dames, placer huit dames sur un échiquier sans qu’elles puissent se prendre entre elles,
	suite de Conway,
	algorithme de dessins récursifs pour le Tapis de Sierpiński (programme informatique), la Courbe du dragon, le flocon, …
	Algorithmes dans le domaine des mathématiques
	calcul de la factorielle d'un nombre, de la Fonction d'Ackermann ou de la suite de Fibonacci,
	algorithme du simplexe, qui minimise une fonction linéaire de variables réelles soumises à des contraintes linéaires,
	fraction continue d'un nombre quadratique, permettant d'extraire une racine carrée, cas particulier de la méthode de Newton
	dans le domaine de l'algèbre : l'algorithme d'unification et le calcul d'une base de Gröbner d'un idéal de polynôme,
	en théorie des graphes qui donne lieu à de nombreux algorithmes.
	Algorithmes pour et dans le domaine de l'informatique
	cryptologie et compression de données
	Informatique musicale
	algorithme génétique en informatique décisionnelle
	Analyse et compilation des langages formels (voir Compilateur et Interprète (informatique))
	allocation de mémoire (ramasse-miettes).
N.B. : L’algorithme est traduit par un ordinogramme
Exemple d’un ordinogramme
 
1.10.	Organigramme de programmation
Un organigramme de programmation (parfois appelé algorigramme, logigramme ou plus rarement ordinogramme) est une représentation graphique normalisée de l'enchaînement des opérations et des décisions effectuées par un programme d'ordinateur.



 
Chapitre deuxième : Traitement de l’information-Symboles de documentation et conventions applicables aux données, aux organigrammes de programmation et d’analyse, aux schémas des réseaux de programmes et des ressources de système.
2.1. Norme ISO
Une norme ISO a été développée, elle porte le numéro ISO 5807-1985. Elle décrit en détail les différents symboles à utiliser pour représenter un programme informatique de manière normalisée.
L’ISO (Organisation internationale de normalisation) est une fédération mondiale d’organismes nationaux de normalisation (comités membres de MO). L’élaboration des Normes internationales est confiée aux comités techniques de I’ISO. 
Chaque comité membre intéressé par une étude a le droit de faire partie du comité technique créé à cet effet. Les organisations internationales, gouvernementales et non gouvernementales, en liaison avec I’ISO, participent également aux travaux.
2.2. Organigramme
Les organigrammes sont largement utilisés pour décrire tous les types de problèmes de traitement de l’information et les moyens de les résoudre. La présente Norme internationale ne limite pas leur emploi aux applications particulières citées à titre d’exemples. 
Des règles internes doivent dans certains cas être élaborées en tenant compte des types de données ou de traitements en cours d’étude. Toutefois, il existe des principes directeurs qui, s’ils sont respectés, améliorent la lisibilité et facilitent les références croisées avec le texte.
Les organigrammes sont composés de symboles ayant une signification donnée, d’un texte explicatif bref et de lignes de raccordement. La présente Norme internationale ne traite pas de la partie textuelle des organigrammes. Toutefois, chaque symbole correspond à un nom (non abrégé si possible) significatif et non ambigu qui est toujours utilisé dans l’ensemble de la documentation. 
Un organigramme peut être utilisé à différents niveaux de détail; le nombre de niveaux dépend de l’importance et de la complexité du problème. Ce niveau de détail doit être choisi pour que les différentes parties ainsi que les relations existant entre ces parties soient compréhensibles dans leur ensemble. 
On définit généralement un organigramme reprenant l’ensemble du système et montrant les principaux éléments constitutifs; cet organigramme représente le premier niveau de la hiérarchie; chaque niveau d’en dessous donne une description plus détaillée d’une ou plusieurs des parties du schéma de niveau immédiatement supérieur.
2.2.1.	Objet et domaine d’application 
La présente Norme internationale précise les symboles à utiliser dans la documentation du traitement de l’information et énumère des règles générales sur les conventions de leur emploi dans : 
a) les organigrammes des données;
b) les organigrammes de programmation; 
c) les organigrammes d’analyse; 
d) les schémas des réseaux des programmes; 
e) les schémas des ressources de systèmes.
2.2.2.	Définitions
	Symbole de base: 
Symbole utilisé lorsque la forme ou la nature précise du traitement ou du support des données (par exemple) est inconnue, ou lorsqu’elle est inutile pour décrire le support réel. 
	Symbole spécifique: 
Symbole utilisé lorsque la nature précise ou la forme (par exemple) du traitement ou du support des données est connue et qu’elle est nécessaire pour décrire le support réel. 
	Organigramme: 
Représentation graphique de la définition, de l’analyse ou de la méthode de résolution d’un problème dans laquelle des symboles sont utilisés pour représenter des opérations, des données, des flux, des équipements, etc.
2.2.3.	Organigramme des données 
L’organigramme des données représente le cheminement des données dans la résolution d’un problème et définit les étapes du traitement ainsi que les différents supports utilisés pour les données. 
Un organigramme de données se compose des éléments suivants : 
a) symboles de données pour indiquer l’existence des données; ces symboles peuvent également préciser le support utilisé pour ces données;
b) symboles de traitement pour indiquer les opérations à exécuter sur les données; ces symboles peuvent également préciser les éléments machine utilisés pour ces traitements;
c) lignes de liaison pour indiquer la circulation des données entre traitements et/ou supports des données; 
d) symboles spéciaux de l’organigramme pour faciliter la lecture et l’écriture


2.2.4.	Organigramme d’analyse
L’organigramme d’analyse représente le contrôle des opérations et la circulation des données à l’intérieur d’un système. 
L’organigramme d’analyse se compose des éléments suivants :
a) symboles de données pour indiquer l’existence de données; ces symboles peuvent également spécifier le support utilisé pour ces données;
b) symboles de traitement pour indiquer les opérations à exécuter sur les données et pour définir le chemin logique à suivre;
c) lignes de liaison pour indiquer la circulation des données entre traitements et/ou supports de données, ainsi que le flux des contrôles entre traitements;
d) symboles spéciaux de l’organigramme pour faciliter la lecture et l’écriture
2.3.	Schéma de réseau de programme 
Le schéma de réseaux de programmes représente le cheminement des activations de chaque programme et les interactions vis-à-vis des données concernées. Chaque programme d’un schéma de ce type n’apparaît qu’une fois alors que dans un organigramme d’analyse, il peut être présent dans plusieurs flux de contrôle.
Un schéma de réseau de programme se compose des éléments suivants :
a) symboles de données pour indiquer l’existence des données ;
b) symboles de traitement pour indiquer les opérations à exécuter sur les données; 
c) lignes de liaison pour indiquer la circulation entre processus et données ainsi que les activations des traitements;
d) des schémas de réseaux symboles spéciaux pour faciliter la lecture et l’écriture
2.4.	Schéma des ressources de système
Le schéma des ressources de système représente la configuration des unités de données et des unités de traitements convenant pour la résolution d’un problème ou d’une série de problèmes.
Un schéma de ressources de système se compose des éléments suivants :
a)	Symboles de données pour montrer les périphériques d’entrée, de sortie ou de support de stockage.
b)	symboles de traitement pour représenter les processeurs, par exemple unités centrales, canaux, etc.; 
c)	lignes de liaison pour représenter le transfert des données entre périphériques et processeurs et les transferts de contrôle entre processeurs;
d)	symboles spéciaux pour faciliter la lecture et l’écriture du schéma. 
2.5.	Symboles
2.5.1.	Symboles de données
	Symboles de base
	Données
Ce symbole représente des données dont le support n’est pas spécifié.
 
	Données mémorisées
Ce symbole représente des données mémorisées sous une forme convenant pour leur traitement, le support n’étant pas spécifié.
 
2.5.2.	Symboles spécifiques
	Mémoire interne
Ce symbole représente des données, le support utilisé étant la mémoire interne. 
 
	Mémoire à accès séquentiel 
Ce symbole représente des données qui peuvent seulement être consultées en accès séquentiel, le support étant par exemple une bande magnétique, une cartouche de bande ou une cassette magnétique.
 

	Mémoire à accès direct
Ce symbole représente des données accessibles directement, le support étant par exemple un disque magnétique, un tambour ou une disquette.
 
	Document
Ce symbole représente des données lisibles par l’homme, le support étant par exemple un état réalisé par imprimante, un document en OCR ou MICR, un microfilm, une bande de comptage, des imprimés de saisie de données.
 
	Entrée manuelle
Ce symbole représente des données, le support étant l’un de ceux pour lesquels l’information est entrée manuellement au moment du traitement, par exemple clavier en ligne, positionnement d’interrupteurs, poussoirs, crayons lumineux, sonde de lecture de code à barres.
 
	Carte
Ce symbole représente des données, le support étant constitué de cartes, par exemple cartes perforées, cartes magnétiques, cartes à lecture graphique, cartes à talons, cartes à marques optiques.
 
	Bande perforée
Ce symbole représente des données, le support étant une bande de papier
 
	Affichage
Ce symbole représente des données, le support étant l’un quelconque de ceux sur lesquels les informations sont affichées à l’intention de l’homme, par exemple écrans vidéo, voyants en ligne.
 
2.5.3.	Symboles de traitement
	Symbole de base
	Traitement
Ce symbole représente une partie quelconque de traitement, par exemple exécution d’une opération définie ou d’un groupe d’opérations produisant une modification de la valeur, de la forme ou de la position d’informations, ou la détermination de la direction suivie parmi toutes les directions possibles.
 
	Symboles de traitements particuliers
	Traitement prédéterminé
Ce symbole représente un traitement nommé composé d’une ou plusieurs opérations ou pas de programme spécifiés par ailleurs, par exemple: un sous-programme, un module.
 
	Opération manuelle
Ce symbole représente tout traitement exécuté par un opérateur humain.
 
	Préparation
Ce symbole représente la modification d’une instruction ou d’un groupe d’instructions pour effectuer une activité ultérieure, par exemple le positionnement d’une bascule ou d’un interrupteur, la modification d’un registre d’index ou l’initialisation d’une routine.
 
	Décision
Ce symbole représente une fonction de type sélection ou décision comportant une seule entrée mais pour laquelle existent plusieurs sorties possibles, dont une seule peut être activée après l’évaluation des conditions définies dans le symbole. Les résultats de l’évaluation peuvent être écrits à côté des lignes représentant les chemins possibles 
 

	Travail en parallèle
 
Exemple
 
NB : Les traitements C, D et E ne peuvent pas commencer avant l’achèvement du traitement A; de même, F peut seulement avoir lieu après l’achèvement de B, C et D. Par contre, le traitement C peut commencer et/ou se terminer avant le début et/ou la fin de D.
	Limite de boucle
Ce symbole en deux parties représente le début et la fin d’une boucle. Les deux parties du symbole ont le même identificateur. Les conditions d’initialisation, d’incrémentation, d’achèvement, etc., sont dans le symbole de début ou de fin, suivant la position de l’opération des tests.
 
Exemple
 
2.5.4.	Symboles de représentation des lignes (symboles linéaires)
	Symbole de base
	Ligne de liaison
Ce symbole représente la circulation des données ou du contrôle.
 
Des têtes de flèches complètes ou ouvertes doivent être ajoutées pour indiquer la circulation des flux si nécessaire ou pour améliorer la lisibilité.
	Symboles spécifiques
	Transfert de contrôle
Ce symbole représente un transfert immédiat du contrôle d’un traitement à un autre, parfois avec un risque de retour direct au traitement d’activation après l’achèvement des opérations du traitement activé. Le type de transfert de contrôle doit être inscrit dans le symbole; exemple : appel, recherche, événement.

 
	Ligne de télécommunications
Ce symbole représente le transfert de données par une ligne de télécommunications.

 
	Tirets
Ce symbole représente une autre relation possible entre deux symboles ou davantage. Il est également utilisé pour entourer une annotation 
 

2.6.	Utilisation simple des symboles
L'organigramme utilise des symboles normalisés représentés ci-dessous :
Symboles normalisés	Commentaires:
 	Les tests ou branchements conditionnels :
	la pointe vers le haut est l'entrée du test,
	la pointe sur le côté est le résultat du test lorsqu'il est faux,
	la pointe vers le bas est le résultat du test lorsqu'il est vrai.
 	Mise à disposition d'une information à traiter ou enregistrement d'une information traitée.
 	Appel de sous-programme.
Sens conventionnel des liaisons : Le sens général des lignes doit être de haut en bas ou/et de gauche à droite. Lorsque le sens ainsi défini n'est pas respecté, il est nécessaire de flécher.
2.6.1.	Différentes structures
Séquence linéaire	Séquence alternative
"si…alors…sinon"	Séquence répétitive
"tant que…faire…"	Séquence répétitive
"répéter…jusqu'à…"
 	 	 	 
Début
	"Traitement 1"
	"Traitement 2"
Fin	Si "condition"
	alors "Traitement 1"
	sinon "Traitement 2"
Fin si	Tant que "condition"
	faire "traitement"
Fin tant que	Répéter "traitement"
jusqu'à "condition"
Une fois l'algorithme défini, l'étape suivante est de coder le programme. Le codage dépend de l'architecture sur laquelle va s'exécuter le programme, de compromis temps-mémoire, et d'autres contraintes. Ces contraintes vont déterminer quel langage de programmation utiliser pour "convertir" l'algorithme en code source.

2.7.	Mise en place des problèmes informatiques en ordinogramme
Les ordinogrammes (ordinogrammes), sont très efficaces pour des programmes moins longs. S’il s’agit des programmes plus robustes, ces derniers exposent leurs limites. C’est pourquoi il est préférable d’utiliser les pseudos codes à la place. Mais cela ne donne pas les raisons de ne pas les maitriser.
2.7.1.	Exemple d’un ordinogramme classique
 

 
2.8.	Transformation du code source
Le code source n'est (presque) jamais utilisable tel quel. Il est généralement écrit dans un langage "de haut niveau", compréhensible pour l'homme, mais pas pour la machine.
2.8.1.	Compilation
Certains langages sont ce qu'on appelle des langages compilés. En toute généralité, la compilation est l'opération qui consiste à transformer un langage source en un langage cible. 
Dans le cas d'un programme, le compilateur va transformer tout le texte représentant le code source du programme, en code compréhensible pour la machine, appelé code machine.
Dans le cas de langages dits compilés, ce qui est exécuté est le résultat de la compilation. Une fois effectuée, l'exécutable obtenu peut être utilisé sans le code source.
Il faut également noter que le résultat de la compilation n'est pas forcément du code machine correspondant à la machine réelle, mais peut être du code compris par une machine virtuelle (c'est-à-dire un programme simulant une machine), auquel cas on parlera de byte code. C'est par exemple le cas en Java. L'avantage est que, de cette façon, un programme peut fonctionner sur n'importe quelle machine réelle, du moment que la machine virtuelle existe pour celle-ci.
Dans le cas d'une requête SQL, la requête est compilée en une expression utilisant les opérateurs de l'algèbre relationnelle. C'est cette expression qui est évaluée par le système de gestion de bases de données.
2.8.2.	Interprétation
D'autres langages ne nécessitent pas de phase spéciale de compilation. La méthode employée pour exécuter le programme est alors différente. La phase de compilation est la plupart du temps incluse dans celle d’exécution. On dit de ce programme qu'il interprète le code source. Par exemple, python ou perl sont des langages interprétés.
Cependant, ce serait faux de dire que la compilation n'intervient pas. L'interprète produit le code machine, au fur et à mesure de l'exécution du programme, en compilant chaque ligne du code source.
2.8.3.	Avantages, inconvénients
Les avantages généralement retenus pour l'utilisation de langages "compilés", est qu'ils sont plus rapides à l'exécution que des langages interprétés, car l'interprète doit être lancé à chaque exécution du programme, ce qui mobilise systématiquement les ressources.
Traditionnellement, les langages interprétés offrent en revanche une certaine portabilité (la capacité à utiliser le code source sur différentes plates-formes), ainsi qu'une facilité pour l'écriture du code. En effet, il n'est pas nécessaire de passer par la phase de compilation pour tester le code source.
2.8.4.	Appellation impropre
Il faut noter qu'on parle abusivement de langages compilés ou interprétés. En effet, le caractère compilé ou interprété ne dépend pas du langage, qui n'est finalement qu'une grammaire et une certaine sémantique. D'ailleurs, certains langages peuvent être utilisés interprétés ou compilés. Par exemple, il est très courant d'utiliser Ruby avec un interprète, mais il existe également des compilateurs pour ce langage.
Néanmoins, l'usage qu'on fait des langages est généralement fixé.
2.8.5.	Test du programme
C'est l'une des étapes les plus importantes de la création d'un programme. En principe, tout programmeur se doit de vérifier chaque partie d'un programme, de le tester. Il existe différents types de test. On peut citer en particulier :
	Test unitaire
	Test d'intégration
	Test de performance
Il convient de noter qu'il est parfois possible de vérifier un programme informatique, c'est-à-dire prouvé, de manière plus ou moins automatique, qu'il assure certaines propriétés.
2.8.6.	Techniques de programmation
	Programmation concurrente
	Programmation déclarative
	Programmation fonctionnelle
	Programmation impérative
	Programmation logique
	Programmation orientée aspect
	Programmation orientée composant
	Programmation orientée objet
	Programmation orientée prototype
	Programmation par contraintes
	Programmation par contrat
	Programmation par intention
	Programmation procédurale
	Programmation structurée
 
Chapitre troisième : Introduction à l’algorithmique
L’algorithmique est un terme d’origine arabe, comme algèbre, amiral ou zénith. Ce n’est pas une excuse pour massacrer son orthographe, ou sa prononciation.
Un algorithme, c’est une suite d’instructions, qui une fois exécutée correctement, conduit à un résultat donné. Si l’algorithme est faux, le résultat est faux.
Pour fonctionner, un algorithme doit donc contenir uniquement des instructions compréhensibles par celui qui devra l’exécuter. C’est d’ailleurs l’un des points délicats pour les rédacteurs de modes d’emploi : les références culturelles, ou lexicales, des utilisateurs, étant variables, un même mode d’emploi peut être très clair pour certains et parfaitement abstraits pour d’autres.
En informatique, il n’y a pas ce problème : les choses auxquelles on doit donner des instructions sont les ordinateurs dépourvus d’intelligence.
Un exemple de problème qui nous concerne tous (oui, même vous) est celui de la cuisine : vous êtes dans une cuisine, vous trouvez du riz, comment le cuire ? Voici une marche à suivre simple :
 	remplir une casserole d'eau ;
 	y ajouter une pincée de sel ;
 	la mettre sur le feu ;
 	attendre l'ébullition de l'eau ;
 	mettre le riz dans la casserole ;
 	le laisser cuire 10 à 15 minutes ;
 	égoutter le riz.
3.1.	Bases de l’algorithme
La maîtrise de l’algorithmique requiert deux qualités, très complémentaires d’ailleurs :
•	il faut avoir une certaine intuition, car aucune recette ne permet de savoir a priori quelles instructions permettront d’obtenir le résultat voulu. C’est là, si l’on y tient, qu’intervient la forme « d’intelligence » requise pour l’algorithmique. Alors, c’est certain, il y a des gens qui possèdent au départ davantage cette intuition que les autres. Cependant, cela s’acquiert. Et ce qu’on appelle l’intuition n’est finalement que de l’expérience tellement répétée que le raisonnement, au départ laborieux, finit par devenir « spontané ».
•	il faut être méthodique et rigoureux. En effet, chaque fois qu’on écrit une série d’instructions qu’on croit justes, il faut systématiquement se mettre mentalement à la place de la machine qui va les exécuter, armé d'un papier et d'un crayon, afin de vérifier si le résultat obtenu est bien celui que l’on voulait. Cette opération ne requiert pas la moindre once d’intelligence. Mais elle reste néanmoins indispensable, si l’on ne veut pas écrire à l’aveuglette.
Et petit à petit, à force de pratique, vous verrez que vous pourrez faire de plus en plus souvent l’économie de cette dernière étape : l’expérience fera que vous « verrez » le résultat produit par vos instructions, au fur et à mesure que vous les écrirez. Naturellement, cet apprentissage est long, et demande des heures de travail patient. Aussi, dans un premier temps, évitez de sauter les étapes : la vérification méthodique, pas à pas, de chacun de vos algorithmes représente plus de la moitié du travail à accomplir… et le gage de vos progrès.
Enfin, les ordinateurs, quels qu’ils soient, ne sont fondamentalement capables de comprendre que quatre catégories d'ordres (en programmation, on n'emploiera pas le terme d'ordre, mais plutôt celui d'instructions). Ces quatre familles d'instructions sont :
•	l’affectation de variables
•	la lecture / écriture
•	les tests
•	les boucles
Un algorithme informatique se ramène donc toujours au bout du compte à la combinaison de ces quatre petites briques de base. Il peut y en avoir quelques-unes, quelques dizaines, et jusqu’à plusieurs centaines de milliers dans certains programmes de gestion. (Cependant, la taille d’un algorithme ne conditionne pas en soi sa complexité : de longs algorithmes peuvent être finalement assez simples, et de petits très compliqués).
3.2.	Algorithme et programmation
Pourquoi apprendre l’algorithmique pour apprendre à programmer ? En quoi a-t-on besoin d’un langage spécial, distinct des langages de programmation compréhensibles par les ordinateurs ?
Parce que l’algorithmique exprime les instructions résolvant un problème donné indépendamment des particularités de tel ou tel langage. Pour prendre une image, si un programme était une dissertation, l’algorithmique serait le plan, une fois mis de côté la rédaction et l’orthographe. Or, vous savez qu’il vaut mieux faire d’abord le plan et rédiger ensuite que l’inverse…
Apprendre l’algorithmique, c’est apprendre à manier la structure logique d’un programme informatique. Cette dimension est présente quelle que soit le langage de programmation ; mais lorsqu’on programme dans un langage (en C, en Visual Basic, etc.) on doit en plus se colleter les problèmes de syntaxe, ou de types d’instructions, propres à ce langage. Apprendre l’algorithmique de manière séparée, c’est donc sérier les difficultés pour mieux les vaincre.
A cela, il faut ajouter que des générations de programmeurs, souvent autodidactes, ayant directement appris à programmer dans tel ou tel langage, ne font pas mentalement clairement la différence entre ce qui relève de la structure logique générale de toute programmation (les règles fondamentales de l’algorithmique) et ce qui relève du langage particulier qu’ils ont appris. Ces programmeurs, non seulement ont beaucoup plus de mal à passer ensuite à un langage différent, mais encore écrivent bien souvent des programmes qui même s’ils sont justes, restent laborieux. Car on n’ignore pas impunément les règles fondamentales de l’algorithmique.
3.3.	Conventions d’écriture d’un algorithme
Historiquement, plusieurs types de notations ont représenté des algorithmes.
Il y a eu notamment une représentation graphique, avec des carrés, des losanges, etc. qu’on appelait des organigrammes. Aujourd’hui, cette représentation est quasiment abandonnée, pour deux raisons. D’abord, parce que dès que l’algorithme commence à grossir un peu, ce n’est plus pratique du tout du tout. Ensuite parce que cette représentation favorise le glissement vers un certain type de programmation, dite non structurée, que l’on tente au contraire d’éviter.
C’est pourquoi on utilise généralement une série de conventions appelée « pseudo-code », qui ressemble à un langage de programmation authentique dont on aurait évacué la plupart des problèmes de syntaxe. Ce pseudo-code est susceptible de varier légèrement d’un livre (ou d’un enseignant) à un autre. C’est bien normal : le pseudo-code, encore une fois, est purement conventionnel ; aucune machine n’est censée le reconnaître. Donc, chaque cuisinier peut faire sa sauce à sa guise, avec ses petites épices bien à lui, sans que cela prête à conséquence.
3.4.	Variables
3.4.1.	Utilité d’une variable
Dans un programme informatique, on va avoir en permanence besoin de stocker provisoirement des valeurs. Il peut s’agir de données issues du disque dur, fournies par l’utilisateur (frappées au clavier),... Il peut aussi s’agir de résultats obtenus par le programme, intermédiaires ou définitifs. Ces données peuvent être de plusieurs types: elles peuvent être des nombres, du texte, etc. Toujours est-il que dès que l’on a besoin de stocker une information au cours d’un programme, on utilise une variable.
Pour employer une image, une variable est une boîte, que le programme (l’ordinateur) va repérer par une étiquette. Pour avoir accès au contenu de la boîte, il suffit de la désigner par son étiquette.
En réalité, dans l’ordinateur, physiquement, il y a un emplacement de mémoire, repéré par une adresse binaire. Si on programmait dans un langage directement compréhensible par la machine, on devrait se fader de désigner nos données par de superbes 10011001 et autres 01001001. Ces langages portent le nom d’assembleur. 
 
3.4.2.	Déclaration des variables
La première chose à faire avant de pouvoir utiliser une variable est de créer la boîte et de lui coller une étiquette. Ceci se fait tout au début de l’algorithme, avant même les instructions proprement dites. C’est ce qu’on appelle la déclaration des variables. 
Le nom de la variable (l’étiquette de la boîte) obéit à des impératifs changeant selon les langages. Toutefois, une règle absolue est qu’un nom de variable peut comporter des lettres et des chiffres, mais qu’il exclut la plupart des signes de ponctuation, en particulier les espaces. Un nom de variable correct commence également impérativement par une lettre. Quant au nombre maximal de signes pour un nom de variable, il dépend du langage utilisé.
En pseudo-code algorithmique, on est bien sûr libre du nombre de signes pour un nom de variable, même si pour des raisons purement pratiques, on évite généralement les noms à rallonge.
Lorsqu’on déclare une variable, il ne suffit pas de créer une boîte (réserver un emplacement mémoire) ; encore doit-on préciser ce que l’on voudra mettre dedans, car de cela dépendent la taille de la boîte (de l’emplacement mémoire) et le type de codage utilisé.
3.4.2.1.	Types numériques classiques
Commençons par le cas très fréquent, celui d’une variable destinée à recevoir des nombres.
Si l’on réserve un octet pour coder un nombre, on ne pourra coder que 28 = 256 valeurs différentes. Cela peut signifier par exemple les nombres entiers de 1 à 256, ou de 0 à 255, ou de –127 à +128… Si l’on réserve deux octets, on a droit à 65 536 valeurs ; avec trois octets, 16 777 216, etc. Et là se pose un autre problème : ce codage doit-il représenter des nombres décimaux ? Des nombres négatifs ?
Bref, le type de codage (autrement dit, le type de variable) choisi pour un nombre va déterminer :
•	les valeurs maximales et minimales des nombres pouvant être stockés dans la variable
•	la précision de ces nombres (dans le cas de nombres décimaux).
Tous les langages, quels qu’ils soient offrent un « bouquet » de types numériques, dont le détail est susceptible de varier légèrement d’un langage à l’autre
Type Numérique	Plage
Byte (octet)	0 à 255
Entier simple	-32 768 à 32 767
Entier long	-2 147 483 648 à 2 147 483 647
Réel simple	-3,40x1038 à -1,40x1045 pour les valeurs négatives
1,40x10-45 à 3,40x1038 pour les valeurs positives
Réel double	1,79x10308 à -4,94x10-324 pour les valeurs négatives
4,94x10-324 à 1,79x10308 pour les valeurs positives

Un bon algorithme ne se contente pas de « marcher » ; il marche en évitant de gaspiller les ressources de la machine. Sur certains programmes de grande taille, l’abus de variables surdimensionnées peut entraîner des ralentissements notables à l’exécution, voire un plantage pur et simple de l’ordinateur. Alors, autant prendre dès le début de bonnes habitudes d’hygiène.
En algorithmique, on ne se tracassera pas trop avec les sous-types de variables numériques. On se contentera donc de préciser qu'il s'agit d'un nombre, en gardant en tête que dans un vrai langage, il faudra être plus précis.
En pseudo-code, une déclaration de variables aura ainsi cette tête :
Variable g en Numérique
ou encore
Variables PrixHT, TauxTVA, PrixTTC en Numérique

3.4.2.2.	Autres types numériques
Certains langages autorisent d’autres types numériques, notamment :
•	le type monétaire (avec strictement deux chiffres après la virgule)
•	le type date (jour/mois/année).
Nous n’emploierons pas ces types dans ce cours ; mais nous le signalons, car vous ne manquerez pas de les rencontrer en programmation proprement dite.
3.4.2.3.	Type alphanumérique
Fort heureusement, les boîtes que sont les variables peuvent contenir bien d’autres informations que des nombres. Sans cela, on serait un peu embêté dès que l’on devrait stocker un nom de famille, par exemple.
On dispose donc également du type alphanumérique (également appelé type caractère, type chaîne ou en anglais, le type string. 
Dans une variable de ce type, on stocke des caractères, qu’il s’agisse de lettres, de signes de ponctuation, d’espaces, ou même de chiffres. Le nombre maximal de caractères pouvant être stockés dans une seule variable string dépend du langage utilisé.
Un groupe de caractères (y compris un groupe de un, ou de zéro caractères), qu’il soit ou non stocké dans une variable, d’ailleurs, est donc souvent appelé chaîne de caractères.
En pseudo-code, une chaîne de caractères est toujours notée entre guillemets pour éviter deux sources principales de possibles confusions :
•	la confusion entre des nombres et des suites de chiffres. Par exemple, 423 peut représenter le nombre 423 (quatre cent vingt-trois), ou la suite de caractères 4, 2, et 3. Et ce n’est pas du tout la même chose ! Avec le premier, on peut faire des calculs, avec le second, point du tout. Dès lors, les guillemets permettent d’éviter toute ambiguïté : s’il n’y en a pas, 423 est quatre cent vingt-trois. S’il y en a, "423" représente la suite des chiffres 4, 2, 3.
• Mais ce n'est pas le pire. L'autre confusion, bien plus grave - et bien plus fréquente – consiste à se mélanger les pinceaux entre le nom d'une variable et son contenu. Pour parler simplement, cela consiste à confondre l'étiquette d'une boîte et ce qu'il y a à l'intérieur…
3.4.2.4.	Type booléen
Le dernier type de variables est le type booléen : on y stocke uniquement les valeurs logiques VRAI et FAUX.
On peut représenter ces notions abstraites de VRAI et de FAUX par tout ce qu'on veut : de l'anglais (TRUE et FALSE) ou des nombres (0 et 1). Peu importe. Ce qui compte, c'est de comprendre que le type booléen est très économique en termes de place mémoire occupée, puisque pour stocker une telle information binaire, un seul bit suffit.
Le type booléen est très souvent négligé par les programmeurs, à tort.
Il est vrai qu'il n'est pas à proprement parler indispensable, et qu'on pourrait écrire à peu près n’importe quel programme en l'ignorant complètement. Pourtant, si le type booléen est mis à disposition des programmeurs dans tous les langages, ce n'est pas pour rien. Le recours aux variables booléennes s'avère très souvent un puissant instrument de lisibilité des algorithmes : il peut faciliter la vie de celui qui écrit l'algorithme, comme de celui qui le relie pour le corriger.
Alors, maintenant, c'est certain, en algorithmique, il y a une question de style : c'est exactement comme dans le langage courant, il y a plusieurs manières de s'exprimer pour dire sur le fond la même chose.
3.5.	Instructions d’affectation
3.5.1.	Syntaxe et signification
En fait, la variable (la boîte) n'est pas un outil bien sorcier à manipuler. On ne peut pas faire trente-six mille choses avec une variable, mais seulement une et une seule.
Cette seule chose qu’on puisse faire avec une variable, c’est l’affecter, c’est-à-dire lui attribuer une valeur. 
En pseudo-code, l'instruction d'affectation se note avec le signe 
Ainsi :
Toto  24
Attribue la valeur 24 à la variable Toto.
Ceci, soit dit en passant, sous-entend impérativement que Toto soit une variable de type numérique. Si Toto a été défini dans un autre type, il faut bien comprendre que cette instruction provoquera une erreur. C’est un peu comme si, en donnant un ordre à quelqu’un, on accolait un verbe et un complément incompatibles, du genre « Epluchez la casserole ». Même dotée de la meilleure volonté du monde, la ménagère lisant cette phrase ne pourrait qu’interrompre dubitativement sa tâche. Alors, un ordinateur, vous pensez bien…
On peut en revanche sans aucun problème attribuer à une variable la valeur d’une autre variable, telle quelle ou modifiée. Par exemple :
Tutu  Toto
Signifie que la valeur de Tutu est maintenant celle de Toto.
Notez bien que cette instruction n’a en rien modifié la valeur de Toto : une instruction d’affectation ne modifie que ce qui est situé à gauche de la flèche.
Tutu  Toto + 4
Si Toto contenait 12, Tutu vaut maintenant 16. De même que précédemment, Toto vaut toujours 12.
Tutu  Tutu + 1
Si Tutu valait 6, il vaut maintenant 7. La valeur de Tutu est modifiée, puisque Tutu est la variable située à gauche de la flèche.
Pour revenir à présent sur le rôle des guillemets dans les chaînes de caractères et sur la confusion numéro 2 signalée plus haut, comparons maintenant deux algorithmes suivants :
Exemple n°1
Début
Riri  "Loulou"
Fifi  "Riri"
Fin

Exemple n°2
Début
Riri  "Loulou"
Fifi  Riri
Fin
La seule différence entre les deux algorithmes consiste dans la présence ou dans l’absence des guillemets lors de la seconde affectation. 
Dans l'exemple n°1, ce que l'on affecte à la variable Fifi, c'est la suite de caractères R – i – r - i. Et à la fin de l’algorithme, le contenu de la variable Fifi est donc « Riri ».
Dans l'exemple n°2, en revanche, Riri étant dépourvu de guillemets, n'est pas considéré comme une suite de caractères, mais comme un nom de variable. Le sens de la ligne devient donc : « affecte à la variable Fifi le contenu de la variable Riri ». A la fin de l’algorithme n°2, la valeur de la variable Fifi est donc « Loulou ». Ici, l’oubli des guillemets conduit certes à un résultat, mais à un résultat différent.
A noter, car c’est un cas très fréquent, que généralement, lorsqu’on oublie les guillemets lors d’une affectation de chaîne, ce qui se trouve à droite du signe d’affectation ne correspond à aucune variable précédemment déclarée et affectée. Dans ce cas, l’oubli des guillemets se solde immédiatement par une erreur d’exécution.
Ceci est une simple illustration. Mais elle résume l’ensemble des problèmes qui surviennent lorsqu’on oublie la règle des guillemets aux chaînes de caractères. 
3.5.2.	Ordre des instructions
Il va de soi que l’ordre dans lequel les instructions sont écrites va jouer un rôle essentiel dans le résultat final. Considérons les deux algorithmes suivants :
Exemple 1
Variable A en Numérique
Début
A  34
A  12
Fin

Exemple 2
Variable A en Numérique
Début
A  12
A  34
Fin
Il est clair que dans le premier cas la valeur finale de A est 12, dans l’autre elle est 34.
Il est tout aussi clair que ceci ne doit pas nous étonner. Lorsqu’on indique le chemin à quelqu’un, dire « prenez tout droit sur 1km, puis à droite » n’envoie pas les gens au même endroit que si l’on dit « prenez à droite puis tout droit pendant 1 km ».
Enfin, il est également clair que si l’on met de côté leur vertu pédagogique, les deux algorithmes ci-dessus sont parfaitement idiots ; à tout le moins ils contiennent une incohérence. Il n’y a aucun intérêt à affecter une variable pour l’affecter différemment juste après. En l’occurrence, on aurait tout aussi bien atteint le même résultat en écrivant simplement :
Exemple 1
Variable A en Numérique
Début
A  12
Fin

Exemple 2
Variable A en Numérique
Début
A  34
Fin
Il va de soi que l’ordre dans lequel les instructions sont écrites va jouer un rôle essentiel dans le résultat final. Considérons les deux algorithmes suivants :
Exemple 1
Variable A en Numérique
Début
A  34
A  12
Fin

Exemple 2
Variable A en Numérique
Début
A  12
A  34
Fin
Il est clair que dans le premier cas la valeur finale de A est 12, dans l’autre elle est 34.
Il est tout aussi clair que ceci ne doit pas nous étonner. Lorsqu’on indique le chemin à quelqu’un, dire « prenez tout droit sur 1km, puis à droite » n’envoie pas les gens au même endroit que si l’on dit « prenez à droite puis tout droit pendant 1 km ».
Enfin, il est également clair que si l’on met de côté leur vertu pédagogique, les deux algorithmes ci-dessus sont parfaitement insensés ; à tout le moins ils contiennent une incohérence. Il n’y a aucun intérêt à affecter une variable pour l’affecter différemment juste après. En l’occurrence, on aurait tout aussi bien atteint le même résultat en écrivant simplement :
Exemple 1
Variable A en Numérique
Début
A  12
Fin

Exemple 2
Variable A en Numérique
Début
A  34
Fin


3.5.3.	Exercices 
Exercice 1.1
Quelles seront les valeurs des variables A et B après exécution des instructions suivantes ?
Variables A, B en Entier
Début
A  1
B  A + 3
A  3
Fin
Exercice 1.2
Quelles seront les valeurs des variables A, B et C après exécution des instructions suivantes ?
Variables A, B, C en Entier
Début
A  5
B  3
C  A + B
A  2
C  B – A
Fin
Exercice 1.3
Quelles seront les valeurs des variables A et B après exécution des instructions suivantes ?
Variables A, B en Entier
Début
A  5
B  A + 4
A  A + 1
B  A – 4
Fin
Exercice 1.4
Quelles seront les valeurs des variables A, B et C après exécution des instructions suivantes ?
Variables A, B, C en Entier
Début
A  3
B  10
C  A + B
B  A + B
A  C
Fin
Exercice 1.5
Quelles seront les valeurs des variables A et B après exécution des instructions suivantes ?
Variables A, B en Entier
Début
A  5
B  2
A  B
B  A
Fin
Moralité : les deux dernières instructions permettent-elles d’échanger les deux valeurs de B et A ? Si l’on inverse les deux dernières instructions, cela change-t-il quelque chose ?
Exercice 1.6
Plus difficile, mais c’est un classique absolu, qu’il faut absolument maîtriser : écrire un algorithme permettant d’échanger les valeurs de deux variables A et B, et ce quel que soit leur contenu préalable.
Exercice 1.7
Une variante du précédent : on dispose de trois variables A, B et C. Ecrivez un algorithme transférant à B la valeur de A, à C la valeur de B et à A la valeur de C (toujours quels que soient les contenus préalables de ces variables). 

3.6.	Expressions et opérateurs
Si on fait le point, on s’aperçoit que dans une instruction d’affectation, on trouve :
•	à gauche de la flèche, un nom de variable, et uniquement cela. En ce monde empli de doutes qu’est celui de l’algorithmique, c’est une des rares règles d’or qui marche à tous les coups : si on voit à gauche d’une flèche d’affectation autre chose qu’un nom de variable, on peut être certain à 100% qu’il s’agit d’une erreur.
•	à droite de la flèche, ce qu’on appelle une expression. Voilà encore un mot qui est trompeur ; en effet, ce mot existe dans le langage courant, où il revêt bien des significations. Mais en informatique, le terme d’expression ne désigne qu’une seule chose, et qui plus est une chose très précise :
Une expression est un ensemble de valeurs, reliées par des opérateurs, et équivalent à une seule valeur.
Par exemple, voyons quelques expressions de type numérique. Ainsi :
7
5+4
123-45+844
Toto-12+5-Riri
Sont toutes des expressions valides, pour peu que Toto et Riri soient bien des nombres. Car dans le cas contraire, la quatrième expression n’a pas de sens. En l’occurrence, les opérateurs employés sont l’addition (+) et la soustraction (-).
Revenons pour le moment sur l’affectation. Une condition supplémentaire (en plus des deux précédentes) de validité d’une instruction d’affectation est que :
•	l’expression située à droite de la flèche soit du même type que la variable située à gauche. C’est très logique : on ne peut pas ranger convenablement des outils dans un sac à provision, ni des légumes dans une trousse à outils… sauf à provoquer un résultat catastrophique.
Si l’un des trois points énumérés ci-dessus n’est pas respecté, la machine sera incapable d’exécuter l’affectation, et déclenchera une erreur.
On va maintenant détailler ce que l’on entend par le terme d’opérateur.
Un opérateur est un signe qui relie deux valeurs, pour produire un résultat.
Les opérateurs possibles dépendent du type des valeurs qui sont en jeu.
3.6.1.	Opérateurs numériques :
Ce sont les quatre opérations arithmétiques tout ce qu’il y a de classique.
+ : Addition
- : Soustraction
* : Multiplication
/ : Division
Mentionnons également le ^ qui signifie « puissance ». 45 au carré s’écrira donc 45^2.
Enfin, on a le droit d’utiliser les parenthèses, avec les mêmes règles qu’en mathématiques. La multiplication et la division ont « naturellement » priorité sur l’addition et la soustraction. Les parenthèses ne sont ainsi utiles que pour modifier cette priorité naturelle.
Cela signifie qu’en informatique, 12 * 3 + 5 et (12 * 3) + 5 valent strictement la même chose, à savoir 41. Les parenthèses modifient la règle de base.
En revanche, 12 * (3 + 5) vaut 12 * 8 soit 96. 
3.6.2.	Opérateur alphanumérique : &
Cet opérateur permet de concaténer, autrement dit d’agglomérer, deux chaînes de caractères. Par exemple :
Variables A, B, C en Caractère
Début
A  "Verone"
B  "Vigie"
C  A & B
Fin
La valeur de C à la fin de l’algorithme est "VeroneVigie
3.6.3.	Opérateurs logiques (ou booléens) :
Il s’agit du ET, du OU, du NON et du mystérieux (mais rarissime XOR).
3.7.	Exercices
Exercice 1.8
Que produit l’algorithme suivant ?
Variables A, B, C en Caractères
Début
A ← "423"
B ← "12"
C ← A + B
Fin
Exercice 1.9
Que produit l’algorithme suivant ?
Variables A, B, C en Caractères
Début
A ← "423"
B ← "12"
C ← A & B
Fin
3.6.4.	Remarques
Maintenant que nous sommes familiers des variables et que nous les manipulons sans problème (mais les neurones en éveil, toutefois), nous attirons l’attention sur la trompeuse similitude de vocabulaire entre les mathématiques et l’informatique. En mathématiques, une « variable » est généralement une inconnue, qui recouvre un nombre non précisé de valeurs. Lorsque nous écrivons :
y = 3 x + 2 les « variables » x et y satisfaisant à l’équation existent en nombre infini (graphiquement, l’ensemble des solutions à cette équation dessine une droite). Lorsque nous écrivons :
ax² + bx + c = 0 la « variable » x désigne les solutions à cette équation, c’est-à-dire zéro, une ou deux valeurs à la fois…
En informatique, une variable possède à un moment donné une valeur et une seule. A la rigueur, elle peut ne pas avoir de valeur du tout (une fois qu’elle a été déclarée, et tant qu’on ne l’a pas affectée. Signalons que dans certains langages, les variables non encore affectées sont considérées comme valant automatiquement zéro). Mais ce qui est important, c’est que cette valeur justement, ne « varie » pas à proprement parler. Du moins ne varie-t-elle que lorsqu’elle est l’objet d’une instruction d’affectation.
La deuxième remarque concerne le signe de l’affectation. 
En algorithmique, comme on l’a vu, c’est le signe. Mais en pratique, la quasi-totalité des langages emploient le signe égal. Et là, pour les débutants, la confusion avec les maths est également facile. En maths, A = B et B = A sont deux propositions strictement équivalentes. En informatique, absolument pas, puisque cela revient à écrire A  B et B  A, deux choses bien différentes. De même, A = A + 1, qui en mathématiques, constitue une équation sans solution, représente en programmation une action tout à fait licite (et de surcroît extrêmement courante). 
La meilleure des vaccinations contre cette confusion consiste à bien employer le signe  en pseudo-code, signe qui a le mérite de ne pas laisser place à l’ambiguïté. Une fois acquis les bons réflexes avec ce signe, vous n’aurez plus aucune difficulté à passer au = des langages de programmation.
3.7.	Ecriture et lecture
Imaginons que nous ayons fait un programme pour calculer le carré d’un nombre, mettons 12. Si on a fait au plus simple, on a écrit un truc du genre :
Variable A en Numérique
Début
A  12^2
Fin
D’une part, ce programme nous donne le carré de 12. Mais si l’on veut le carré d’un autre nombre que 12, il faut réécrire le programme.
D’autre part, le résultat est indubitablement calculé par la machine. Mais elle le garde soigneusement pour elle, et le pauvre utilisateur qui fait exécuter ce programme, lui, ne saura jamais quel est le carré de 12.
Dans un sens, ces instructions permettent à l’utilisateur de rentrer des valeurs au clavier pour qu’elles soient utilisées par le programme. Cette opération est la lecture.
Dans l’autre sens, d’autres instructions permettent au programme de communiquer des valeurs à l’utilisateur en les affichant à l’écran. Cette opération est l’écriture.
Remarque essentielle : A première vue, on peut avoir l’impression que les informaticiens étaient beurrés comme des petits lus lorsqu’ils ont baptisé ces opérations ; puisque quand l’utilisateur doit écrire au clavier, on appelle ça la lecture, et quand il doit lire sur l’écran on appelle çà l’écriture. 
Un algorithme, c’est une suite d’instructions qui programme la machine, pas l’utilisateur. Donc quand on dit à la machine de lire une valeur, cela implique que l’utilisateur va devoir écrire cette valeur. Et quand on demande à la machine d’écrire une valeur, c’est pour que l’utilisateur puisse la lire. Lecture et écriture sont donc des termes qui comme toujours en programmation, doivent être compris du point de vue de la machine qui sera chargée de les exécuter. Et là, tout devient parfaitement logique.
3.7.1.	Instructions de lecture et d’écriture
Tout bêtement, pour que l’utilisateur entre la (nouvelle) valeur de Titi, on mettra :
Lire Titi
Dès que le programme rencontre une instruction Lire, l’exécution s’interrompt, attendant la frappe d’une valeur au clavier
Dès lors, aussitôt que la touche Entrée (Enter) a été frappée, l’exécution reprend. Dans le sens inverse, pour écrire quelque chose à l’écran, c’est aussi simple que :
Ecrire Toto
Avant de Lire une variable, il est très fortement conseillé d’écrire des libellés à l’écran, afin de prévenir l’utilisateur de ce qu’il doit frapper (sinon, l’utilisateur passera son temps à se demander ce que l’ordinateur attend de lui…) :
Ecrire "Entrez votre nom : "
Lire NomFamille
Lecture et Ecriture sont des instructions algorithmiques qui ne présentent pas de difficultés particulières, une fois qu’on a bien assimilé ce problème du sens du dialogue (homme  machine, ou machine  homme).
3.7.1.	Exercices
Exercice 2.1
Quel résultat produit le programme suivant ?
Variables val, double numériques
Début
Val  231
Double  Val * 2
Ecrire Val
Ecrire Double
Fin
Exercice 2.2
Ecrire un programme qui demande un nombre à l’utilisateur, puis qui calcule et affiche le carré de ce nombre.
Exercice 2.3
Ecrire un programme qui lit le prix HT d’un article, le nombre d’articles et le taux de TVA, et qui fournit le prix total TTC correspondant. Faire en sorte que des libellés apparaissent clairement.
Exercice 2.4
Ecrire un algorithme utilisant des variables de type chaîne de caractères, et affichant quatre variantes possibles de la célèbre « belle marquise, vos beaux yeux me font mourir d’amour ». On ne se soucie pas de la ponctuation, ni des majuscules.
3.8.	Tests
En informatique, un test désigne une procédure de vérification partielle d'un système. Son objectif principal est d'identifier un nombre maximum de comportements problématiques du logiciel. Il permet ainsi, dès lors que les problèmes identifiés seront corrigés, d'en augmenter la qualité.
D'une manière plus générale, le test désigne toutes les activités qui consistent à rechercher des informations quant à la qualité du système afin de permettre la prise de décisions.
3.8.1.	Structure d’un test
Il n’y a que deux formes possibles pour un test ; la première est la plus simple, la seconde la plus complexe.
Si booléen Alors
 Instructions
Finsi
Si booléen Alors
 Instructions 1
Sinon
 Instructions 2
Finsi
Un booléen est une expression dont la valeur est VRAI ou FAUX. Cela peut donc être (il n’y a que deux possibilités) :
•	une variable (ou une expression) de type booléen
•	une condition
Toujours est-il que la structure d’un test est relativement claire. Dans la forme la plus simple, arrivé à la première ligne (Si… Alors) la machine examine la valeur du booléen. Si ce booléen a pour valeur VRAI, elle exécute la série d’instructions. Cette série d’instructions peut être très brève comme très longue, cela n’a aucune importance. En revanche, dans le cas où le booléen est faux, l'ordinateur saute directement aux instructions situées après le FinSi.
Dans le cas de la structure complète, c'est à peine plus compliqué. Dans le cas où le booléen est VRAI, et après avoir exécuté la série d'instructions 1, au moment où elle arrive au mot « Sinon », la machine saute directement à la première instruction située après le « FinSi ». De même, au cas où le booléen a comme valeur « Faux », la machine saute directement à la première ligne située après le « Sinon » et exécute l’ensemble des « instructions 2 ». Dans tous les cas, les instructions situées juste après le FinSi seront exécutées normalement.
En fait, la forme simplifiée correspond au cas où l’une des deux « branches » du Si est vide. Dès lors, plutôt qu’écrire « sinon ne rien faire du tout », il est plus simple de ne rien écrire. Et laisser un Si... complet, avec une des deux branches vides, est considéré comme une très grosse maladresse pour un programmeur, même si cela ne constitue pas à proprement parler une faute.
Exprimé sous forme de pseudo-code, donnerait donc quelque chose du genre :
Si booléen Alors
 Instructions
Finsi
Si booléen Alors
 Instructions 1
Sinon
 Instructions 2
Finsi
Allez tout droit jusqu’au prochain carrefour
Si la rue à droite est autorisée à la circulation Alors
 Tournez à droite
 Avancez
 Prenez la deuxième à gauche
Sinon
 Continuez jusqu’à la prochaine rue à droite
 Prenez cette rue
 Prenez la première à droite
Finsi
3.9.	Conditions
Une condition est une comparaison
Elle signifie qu’une condition est composée de trois éléments :
•	une valeur
•	un opérateur de comparaison
•	une autre valeur
Les valeurs peuvent être a priori de n’importe quel type (numériques, caractères…). Mais si l’on veut que la comparaison ait un sens, il faut que les deux valeurs de la comparaison soient du même type.
Les opérateurs de comparaison sont :
•	égal à…
•	différent de…
•	strictement plus petit que…
•	strictement plus grand que…
•	plus petit ou égal à…
•	plus grand ou égal à…
L’ensemble des trois éléments constituant la condition constitue donc, si l’on veut, une affirmation, qui a un moment donné est VRAIE ou FAUSSE.
A noter que ces opérateurs de comparaison peuvent tout à fait s’employer avec des caractères. Ceux-ci sont codés par la machine dans l’ordre alphabétique (rappelez-vous le code ASCII), les majuscules étant systématiquement placées avant les minuscules. Ainsi on a :
“t” < “w” VRAI
“Maman” > “Papa“ FAUX
“maman” > “Papa” VRAI

Remarque très importante :
En formulant une condition dans un algorithme, il faut se méfier comme de la peste de certains raccourcis du langage courant, ou de certaines notations valides en mathématiques, mais qui mènent à des non-sens informatiques. Prenons par exemple la phrase « Toto est compris entre 5 et 8 ». On peut être tenté de la traduire par : 5 < Toto < 8
Or, une telle expression, qui a du sens en français, comme en mathématiques, ne veut rien dire en programmation. En effet, elle comprend deux opérateurs de comparaison, soit un de trop, et trois valeurs, soit là aussi une de trop. On va voir dans un instant comment traduire convenablement une telle condition.
3.9.1.	Exercices
Exercice 3.1
Ecrire un algorithme qui demande un nombre à l’utilisateur, et l’informe ensuite si ce nombre est positif ou négatif (on laisse de côté le cas où le nombre vaut zéro)

Exercice 3.1
Variable n en Entier
Début
Ecrire "Entrez un nombre : "
Lire n
Si n > 0 Alors
 Ecrire "Ce nombre est positif”
Sinon
 Ecrire "Ce nombre est négatif"
Finsi
Fin
3.10.	Conditions composées
Certains problèmes exigent parfois de formuler des conditions qui ne peuvent pas être exprimées sous la forme simple exposée ci-dessus. Reprenons le cas « Toto est inclus entre 5 et 8 ». En fait cette phrase cache non une, mais deux conditions. Car elle revient à dire que « Toto est supérieur à 5 et Toto est inférieur à 8 ». Il y a donc bien là deux conditions, reliées par ce qu’on appelle un opérateur logique, le mot ET.
Comme on l’a évoqué plus haut, l’informatique met à notre disposition quatre opérateurs logiques : ET, OU, NON, et XOR.
•	Le ET a le même sens en informatique que dans le langage courant. Pour que "Condition1 ET Condition2" soit VRAI, il faut impérativement que Condition1 soit VRAI et que Condition2 soit VRAI. Dans tous les autres cas, "Condition 1 et Condition2" sera faux.
•	Il faut se méfier un peu plus du OU. Pour que "Condition1 OU Condition2" soit VRAI, il suffit que Condition1 soit VRAIE ou que Condition2 soit VRAIE. Le point important est que si Condition1 est VRAIE et que Condition2 est VRAIE aussi, Condition1 OU Condition2 reste VRAIE. Le OU informatique ne veut donc pas dire « ou bien »
•	Le XOR (ou OU exclusif) fonctionne de la manière suivante. Pour que "Condition1 XOR Condition2" soit VRAI, il faut que soit Condition1 soit VRAI, soit que Condition2 soit VRAI. Si toutes les deux sont fausses, ou que toutes les deux sont VRAI, alors le résultat global est considéré comme FAUX. Le XOR est donc l'équivalent du "ou bien" du langage courant.
Toutefois, le XOR est une rareté, dont il n’est pas strictement indispensable de s’encombrer en programmation.
•	Enfin, le NON inverse une condition : NON(Condition1) est VRAI si Condition1 est FAUX, et il sera FAUX si Condition1 est VRAI. C'est l'équivalent pour les booléens du signe "moins" que l'on place devant les nombres.
Alors, vous vous demandez peut-être à quoi sert ce NON. Après tout, plutôt qu’écrire NON (Prix > 20), il serait plus simple d’écrire tout bonnement Prix=<20. Dans ce cas précis, c’est évident qu’on se complique inutilement la vie avec le NON. Mais si le NON n'est jamais indispensable, il y a tout de même des situations dans lesquelles il s'avère bien utile.
On représente fréquemment tout ceci dans des tables de vérité (C1 et C2 représentent deux conditions, et on envisage à chaque fois les quatre cas possibles)
Tableau 1
C1 et C2	C2 Vrai	C2 Faux
C1 Vrai	Vrai	Faux
C1 Faux	Faux	Faux
Tableau 2
C1 ou C2	C2 Vrai	C2 Faux
C1 Vrai	Vrai	Vrai
C1 Faux	Vrai	Faux
Tableau 3

C1 xor C2	C2 Vrai	C2 Faux
C1 Vrai	Faux	Vrai
C1 Faux	Vrai	Faux
Tableau 4
Non C1	 
C1 Vrai	Faux
C1 Faux	Vrai

3.10.1.	Exercices 
Exercice 3.2
Ecrire un algorithme qui demande deux nombres à l’utilisateur et l’informe ensuite si leur produit est négatif ou positif (on laisse de côté le cas où le produit est nul). Attention toutefois : on ne doit pas calculer le produit des deux nombres.
Exercice 3.3
Ecrire un algorithme qui demande trois noms à l’utilisateur et l’informe ensuite s’ils sont rangés ou non dans l’ordre alphabétique.
3.11.	Tests imbriqués
Graphiquement, on peut très facilement représenter un SI comme un aiguillage de chemin de fer (ou un aiguillage de train électrique, c’est moins lourd à porter). Un SI ouvre donc deux voies, correspondant à deux traitements différents. Mais il y a des tas de situations où deux voies ne suffisent pas. Par exemple, un programme devant donner l’état de l’eau selon sa température doit pouvoir choisir entre trois réponses possibles (solide, liquide ou gazeuse).
Une première solution serait la suivante :
Variable Temp en Entier
Début
Ecrire "Entrez la température de l’eau :"
Lire Temp
Si Temp =< 0 Alors
 Ecrire "C’est de la glace"
FinSi
Si Temp > 0 Et Temp < 100 Alors
 Ecrire "C’est du liquide"
Finsi
Si Temp > 100 Alors
 Ecrire "C’est de la vapeur"
Finsi
Fin
Nous constatons que c’est un peu laborieux. Les conditions se ressemblent plus ou moins, et surtout on oblige la machine à examiner trois tests successifs alors que tous portent sur une même chose, la température de l'eau (la valeur de la variable Temp). Il serait ainsi bien plus rationnel d’imbriquer les tests de cette manière :
Variable Temp en Entier
Début
Ecrire "Entrez la température de l’eau :"
Lire Temp
Si Temp =< 0 Alors
 Ecrire "C’est de la glace"
Sinon
 Si Temp < 100 Alors
 Ecrire "C’est du liquide"
 Sinon
 Ecrire "C’est de la vapeur"
 Finsi
Finsi
Fin
Nous avons fait des économies : au lieu de devoir taper trois conditions, dont une composée, nous n’avons plus que deux conditions simples. Mais aussi, et surtout, nous avons fait des économies sur le temps d’exécution de l’ordinateur. Si la température est inférieure à zéro, celui-ci écrit dorénavant « C’est de la glace » et passe directement à la fin, sans être ralenti par l’examen d’autres possibilités (qui sont forcément fausses).
Cette deuxième version n’est donc pas seulement plus simple à écrire et plus lisible, elle est également plus performante à l’exécution.
Les structures de tests imbriqués sont donc un outil indispensable à la simplification et à l’optimisation des algorithmes.
3.11.1.	Exercices
Exercice 3.4
Ecrire un algorithme qui demande un nombre à l’utilisateur, et l’informe ensuite si ce nombre est positif ou négatif (on inclut cette fois le traitement du cas où le nombre vaut zéro).
Exercice 3.5
Ecrire un algorithme qui demande deux nombres à l’utilisateur et l’informe ensuite si le produit est négatif ou positif (on inclut cette fois le traitement du cas où le produit peut être nul). Attention toutefois, on ne doit pas calculer le produit.
Exercice 3.6
Ecrire un algorithme qui demande l’âge d’un enfant à l’utilisateur. Ensuite, il l’informe de sa catégorie :
•	"Poussin" de 6 à 7 ans
•	"Pupille" de 8 à 9 ans
•	"Minime" de 10 à 11 ans
•	"Cadet" après 12 ans
Peut-on concevoir plusieurs algorithmes équivalents menant à ce résultat.
3.12.	Aiguillage et la gare de tri
Dans un programme, une structure SI peut être facilement comparée à un aiguillage de train. La voie principale se sépare en deux, le train devant rouler ou sur l’une, ou sur l’autre, et les deux voies se rejoignant tôt ou tard pour ne plus en former qu’une seule, lors du FinSi. On peut schématiser cela ainsi :
 
Mais dans certains cas, ce ne sont pas deux voies qu’il nous faut, mais trois, ou même plus. Dans le cas de l’état de l’eau, il nous faut trois voies pour notre « train », puisque l’eau peut être solide, liquide ou gazeuse. Alors, nous n’avons pas eu le choix : pour deux voies, il nous fallait un aiguillage, pour trois voies il nous en faut deux, imbriqués l’un dans l’autre.
Cette structure (telle que nous l’avons programmée à la page précédente) devrait être schématisée comme suit :
 
Soyons bien clairs : cette structure est la seule possible du point de vue logique (même si on peut toujours mettre le bas en haut et le haut en bas). Mais du point de vue de l’écriture, le pseudo-code algorithmique admet une simplification supplémentaire. Ainsi, il est possible (mais non obligatoire, que l’algorithme initial :
Variable Temp en Entier
Début
Ecrire "Entrez la température de l’eau :"
Lire Temp
Si Temp =< 0 Alors
 Ecrire "C'est de la glace"
Sinon
 Si Temp < 100 Alors
 Ecrire "C’est du liquide"
 Sinon
 Ecrire "C’est de la vapeur"
 Finsi
Finsi
Fin
devienne :
Variable Temp en Entier
Début
Ecrire "Entrez la température de l’eau :"
Lire Temp
Si Temp =< 0 Alors
 Ecrire "C’est de la glace"
SinonSi Temp < 100 Alors
 Ecrire "C’est du liquide"
Sinon
 Ecrire "C’est de la vapeur"
Finsi
Fin
Dans le cas de tests imbriqués, le Sinon et le Si peuvent être fusionnés en un SinonSi. On considère alors qu’il s’agit d’un seul bloc de test, conclu par un seul FinSi
Le SinonSi permet en quelque sorte de créer (en réalité, de simuler) des aiguillages à plus de deux branches. On peut ainsi enchaîner les SinonSi les uns derrière les autres pour simuler un aiguillage à autant de branches que l’on souhaite.
3.13.	Variables booléennes
Il existe un type de variables (les booléennes) susceptibles de stocker les valeurs VRAI ou FAUX. En fait, on peut donc entrer des conditions dans ces variables, et tester ensuite la valeur de ces variables.
Reprenons l’exemple de l’eau. On pourrait le réécrire ainsi :
Variable Temp en Entier
Variables A, B en Booléen
Début
Ecrire "Entrez la température de l’eau :"
Lire Temp
A  Temp =< 0
B  Temp < 100
Si A Alors
 Ecrire "C’est de la glace"
SinonSi B Alors
 Ecrire "C’est du liquide"
Sinon
 Ecrire "C’est de la vapeur"
Finsi
Fin
A priori, cette technique ne présente guère d’intérêt : on a alourdi plutôt qu’allégé l’algorithme de départ, en ayant recours à deux variables supplémentaires.
•	Mais souvenons-nous : une variable booléenne n’a besoin que d’un seul bit pour être stockée. De ce point de vue, l’alourdissement n’est donc pas considérable.
•	dans certains cas, notamment celui de conditions composées très lourdes (avec plein de ET et de OU tout partout) cette technique peut faciliter le travail du programmeur, en améliorant nettement la lisibilité de l’algorithme. Les variables booléennes peuvent également s’avérer très utiles pour servir de flag, technique dont on reparlera plus loin.
3.14.	Logique
3.14.1.	Entre ‘ET’ et ‘OU’ 
Remarque 
Dans le cas de conditions composées, les parenthèses jouent un rôle fondamental.
Variables A, B, C, D, E en Booléen
Variable X en Entier
Début
Lire X
A  X > 12
B  X > 2
C  X < 6
D  (A ET B) OU C
E  A ET (B OU C)
Ecrire D, E
Fin
Si X = 3, alors on remarque que D sera VRAI alors que E sera FAUX.
S’il n’y a dans une condition que des ET, ou que des OU, en revanche, les parenthèses ne changent strictement rien.
Dans une condition composée employant à la fois des opérateurs ET et des opérateurs OU, la présence de parenthèses possède une influence sur le résultat, tout comme dans le cas d’une expression numérique comportant des multiplications et des additions.
On en arrive à une autre propriété des ET et des OU, bien plus intéressante.
Spontanément, on pense souvent que ET et OU s’excluent mutuellement, au sens où un problème donné s’exprime soit avec un ET, soit avec un OU. Pourtant, ce n’est pas si évident.
Quand faut-il ouvrir la fenêtre de la salle ? Uniquement si les conditions l’imposent, à savoir :
Si il fait trop chaud ET il ne pleut pas Alors
 Ouvrir la fenêtre
Sinon 
 Fermer la fenêtre 
Finsi
Cette petite règle pourrait tout aussi bien être formulée comme suit :
Si il ne fait pas trop chaud OU il pleut Alors
 Fermer la fenêtre
Sinon
 Ouvrir la fenêtre
Finsi
Ces deux formulations sont strictement équivalentes. Ce qui nous amène à la conclusion suivante :
Toute structure de test requérant une condition composée faisant intervenir l’opérateur ET peut être exprimée de manière équivalente avec un opérateur OU, et réciproquement.
Ceci est moins surprenant qu’il n’y paraît au premier abord. Jetez pour vous en convaincre un œil sur les tables de vérité, et vous noterez la symétrie entre celle du ET et celle du OU. Dans les deux tables, il y a trois cas sur quatre qui mènent à un résultat, et un sur quatre qui mène au résultat inverse. Alors, rien d’étonnant à ce qu’une situation qui s’exprime avec une des tables (un des opérateurs logiques) puisse tout aussi bien être exprimée avec l’autre table (l’autre opérateur logique). Toute l’astuce consiste à savoir effectuer correctement ce passage.
Bien sûr, on ne peut pas se contenter de remplacer purement et simplement les ET par des OU ; ce serait un peu facile. La règle d’équivalence est la suivante (on peut la vérifier sur l’exemple de la fenêtre) :
Si A ET B Alors
 Instructions 1
Sinon
 Instructions 2
Finsi

équivaut à :

Si NON A OU NON B Alors
 Instructions 2
Sinon
 Instructions 1
Finsi
Cette règle porte le nom de transformation de Morgan, du nom du mathématicien anglais qui l'a formulée.
3.14.2.	Exercices
Exercice 4.1
Formulez un algorithme équivalent à l’algorithme suivant :
Si Tutu > Toto + 4 OU Tata = "OK" Alors
 Tutu  Tutu + 1
Sinon
 Tutu  Tutu – 1
Finsi
Exercice 4.2
Cet algorithme est destiné à prédire l'avenir, et il doit être infaillible !
Il lira au clavier l’heure et les minutes, et il affichera l’heure qu’il sera une minute plus tard. Par exemple, si l'utilisateur tape 21 puis 32, l'algorithme doit répondre :
"Dans une minute, il sera 21 heure(s) 33".
NB : on suppose que l'utilisateur entre une heure valide. Pas besoin donc de la vérifier.
Exercice 4.3
De même que le précédent, cet algorithme doit demander une heure et en afficher une autre. Mais cette fois, il doit gérer également les secondes, et afficher l'heure qu'il sera une seconde plus tard.
Par exemple, si l'utilisateur tape 21, puis 32, puis 8, l'algorithme doit répondre : "Dans une seconde, il sera 21 heure(s), 32 minute(s) et 9 seconde(s)".
NB : là encore, on suppose que l'utilisateur entre une date valide.
Exercice 4.4
Un magasin de reprographie facture 0,10 E les dix premières photocopies, 0,09 E les vingt suivantes et 0,08 E au-delà. Ecrivez un algorithme qui demande à l’utilisateur le nombre de photocopies effectuées et qui affiche la facture correspondante.
Exercice 4.5
Les habitants de Kadutu paient l’impôt selon les règles suivantes :
•	les hommes de plus de 20 ans paient l’impôt
•	les femmes paient l’impôt si elles ont entre 18 et 35 ans
•	les autres ne paient pas d’impôt
Le programme demandera donc l’âge et le sexe du Kadutois, et se prononcera donc ensuite sur le fait que l’habitant est imposable.
3.15.	Style
Ce titre un peu provocateur (mais néanmoins justifié) a pour but d’attirer maintenant votre attention sur un fait fondamental en algorithmique, fait que plusieurs remarques précédentes ont déjà dû vous faire soupçonner : il n’y a jamais une seule manière juste de traiter les structures alternatives. Et plus généralement, il n’y a jamais une seule manière juste de traiter un problème. Entre les différentes possibilités, qui ne sont parfois pas meilleures les unes que les autres, le choix est une affaire de style.
C’est pour cela qu’avec l’habitude, on reconnaît le style d’un programmeur aussi sûrement que s’il s’agissait de style littéraire.
Reprenons nos opérateurs de comparaison maintenant familiers, le ET et le OU. En fait, on s’aperçoit que l’on pourrait tout à fait s’en passer. Par exemple, pour reprendre l’exemple de la fenêtre de la salle :
Si il fait trop chaud ET il ne pleut pas Alors
 Ouvrir la fenêtre
Sinon
 Fermer la fenêtre
Finsi
Possède un parfait équivalent algorithmique sous la forme de :
Si il fait trop chaud Alors
 Si il ne pleut pas Alors
 Ouvrir la fenêtre
 Sinon
 Fermer la fenêtre
 Finsi
Sinon
 Fermer la fenêtre
Finsi
Dans cette dernière formulation, nous n’avons plus recours à une condition composée.
Et comme tout ce qui s’exprime par un ET peut aussi être exprimé par un OU, nous en concluons que le OU peut également être remplacé par un test imbriqué supplémentaire. 
On peut ainsi poser cette règle stylistique générale :
Dans une structure alternative complexe, les conditions composées, l’imbrication des structures de tests et l’emploi des variables booléennes ouvrent la possibilité de choix stylistiques différents. L’alourdissement des conditions allège les structures de tests et le nombre des booléens nécessaires ; l’emploi de booléens supplémentaires permet d’alléger les conditions et les structures de tests, et ainsi de suite.
3.15.1.	Exercices
Exercice 4.6
Les élections législatives, au Nord-Kivu, obéissent à la règle suivante : lorsque l'un des candidats obtient plus de 50% des suffrages, il est élu dès le premier tour. En cas de deuxième tour, peuvent participer uniquement les candidats ayant obtenu au moins 12,5% des voix au premier tour.
Vous devez écrire un algorithme qui permette la saisie des scores de quatre candidats au premier tour. Cet algorithme traitera ensuite le candidat numéro 1 (et uniquement lui) : il dira s'il est élu, battu, s'il se trouve en ballottage favorable (il participe au second tour en étant arrivé en tête à l'issue du premier tour) ou défavorable (il participe au second tour sans avoir été en tête au premier tour).

Exercice 4.7
Une compagnie d'assurance automobile propose à ses clients quatre familles de tarifs identifiables par une couleur, du moins au plus onéreux : tarifs bleu, vert, orange et rouge. Le tarif dépend de la situation du conducteur :
•	un conducteur de moins de 25 ans et titulaire du permis depuis moins de deux ans, se voit attribuer le tarif rouge, si toutefois il n'a jamais été responsable d'accident. Sinon, la compagnie refuse de l'assurer.
•	un conducteur de moins de 25 ans et titulaire du permis depuis plus de deux ans, ou de plus de 25 ans mais titulaire du permis depuis moins de deux ans a le droit au tarif orange s'il n'a jamais provoqué d'accident, au tarif rouge pour un accident, sinon il est refusé.
•	un conducteur de plus de 25 ans titulaire du permis depuis plus de deux ans bénéficie du tarif vert s'il n'est à l'origine d'aucun accident et du tarif orange pour un accident, du tarif rouge pour deux accidents, et refusé au-delà
•	De plus, pour encourager la fidélité des clients acceptés, la compagnie propose un contrat de la couleur immédiatement la plus avantageuse s'il est entré dans la maison depuis plus de cinq ans. Ainsi, s'il satisfait à cette exigence, un client normalement "vert" devient "bleu", un client normalement "orange" devient "vert", et le "rouge" devient orange.
Ecrire l'algorithme permettant de saisir les données nécessaires (sans contrôle de saisie) et de traiter ce problème. 
Exercice 4.8
Ecrivez un algorithme qui après avoir demandé un numéro de jour, de mois et d'année à l'utilisateur, renvoie s'il s'agit ou non d'une date valide.
Cet exercice est certes d’un manque d’originalité affligeant, mais après tout, en algorithmique comme ailleurs, il faut connaître ses classiques. Et quand on a fait cela une fois dans sa vie, on apprécie pleinement l’existence d’un type numérique « date » dans certains langages…).
Il n'est sans doute pas inutile de rappeler rapidement que le mois de février compte 28 jours, sauf si l’année est bissextile, auquel cas il en compte 29. L’année est bissextile si elle est divisible par quatre. Toutefois, les années divisibles par 100 ne sont pas bissextiles, mais les années divisibles par 400 le sont.
Un dernier petit détail : vous ne savez pas, pour l’instant, exprimer correctement en pseudo-code l’idée qu’un nombre A est divisible par un nombre B. Aussi, vous vous contenterez d’écrire en bons télégraphistes que A divisible par B se dit « A dp B »
Si vous avez compris ce qui précède, et que l'exercice de la date ne vous pose plus aucun problème, alors vous savez tout ce qu'il y a à savoir sur les tests pour affronter n'importe quelle situation. 
3.16.	Boucles
Les boucles constituent la seule vraie structure logique caractéristique de la programmation. Si vous avez utilisé un tableur comme Excel, par exemple, vous avez sans doute pu manier des choses équivalentes aux variables (les cellules, les formules) et aux tests (la fonction SI…). Mais les boucles, ça, ça n'a aucun équivalent. Cela n'existe que dans les langages de programmation proprement dits.
Le maniement des boucles, est tout de même ce qui sépare en informatique le programmeur de l'utilisateur, même averti.
Pour la notion des boucles on parle également de structures répétitives, voire carrément de structures itératives.
3.16.1.	Importance de la boucle
Prenons le cas d’une saisie au clavier (une lecture), où par exemple, le programme pose une question à laquelle l’utilisateur doit répondre par O (Oui) ou N (Non). Mais tôt ou tard, l’utilisateur, facétieux ou maladroit, risque de taper autre chose que la réponse attendue. Dès lors, le programme peut planter soit par une erreur d’exécution (parce que le type de réponse ne correspond pas au type de la variable attendu) soit par une erreur fonctionnelle (il se déroule normalement jusqu’au bout, mais en produisant des résultats fantaisistes).
Alors, dans tout programme un tant soit peu sérieux, on met en place ce qu’on appelle un contrôle de saisie, afin de vérifier que les données entrées au clavier correspondent bien à celles attendues par l’algorithme.
Variable Rep en Caractère
Début
Ecrire "Voulez vous un café ? (O/N)"
Lire Rep
Si Rep <> "O" et Rep <> "N" Alors
 Ecrire "Saisie erronnée. Recommencez"
 Lire Rep
FinSi
Fin
C’est impeccable. Du moins tant que l’utilisateur a le bon goût de ne se tromper qu’une seule fois, et d’entrer une valeur correcte à la deuxième demande. Si l’on veut également bétonner en cas de deuxième erreur, il faudrait rajouter un SI. Et ainsi de suite, on peut rajouter des centaines de SI, et écrire un algorithme aussi lourd, on n’en sortira pas.
La solution consistant à aligner des SI… en pagaille est donc une impasse. La seule issue est donc de flanquer une structure de boucle, qui se présente ainsi :
TantQue booléen
 …
 Instructions
 …
FinTantQue
Le principe est simple : le programme arrive sur la ligne du TantQue. Il examine alors la valeur du booléen (qui, peut être une variable booléenne ou, plus fréquemment, une condition). Si cette valeur est VRAI, le programme exécute les instructions qui suivent, jusqu’à ce qu’il rencontre la ligne FinTantQue. Il retourne ensuite sur la ligne du TantQue, procède au même examen, et ainsi de suite. Le manège enchanté ne s’arrête que lorsque le booléen prend la valeur FAUX.
Illustration avec notre problème de contrôle de saisie. Une première approximation de la solution consiste à écrire :
Variable Rep en Caractère
Début
Ecrire "Voulez vous un café ? (O/N)"
TantQue Rep <> "O" et Rep <> "N"
 Lire Rep
FinTantQue
Fin
Là, on a le squelette de l’algorithme correct. Mais de même qu’un squelette ne suffit pas pour avoir un être vivant viable, il va nous falloir ajouter quelques muscles et organes sur cet algorithme pour qu’il fonctionne correctement.
Son principal défaut est de provoquer une erreur à chaque exécution. En effet, l’expression booléenne qui figure après le TantQue interroge la valeur de la variable Rep. Malheureusement, cette variable, si elle a été déclarée, n’a pas été affectée avant l’entrée dans la boucle. On teste donc une variable qui n’a pas de valeur, ce qui provoque une erreur et l’arrêt immédiat de l’exécution. Pour éviter ceci, on n’a pas le choix : il faut que la variable Rep ait déjà été affectée avant qu’on en arrive au premier tour de boucle. Pour cela, on peut faire une première lecture de Rep avant la boucle. Dans ce cas, celle-ci ne servira qu’en cas de mauvaise saisie lors de cette première lecture. L’algorithme devient alors :
Variable Rep en Caractère
Début
Ecrire "Voulez vous un café ? (O/N)"
Lire Rep
TantQue Rep <> "O" et Rep <> "N"
 Lire Rep
FinTantQue
Fin
Une autre possibilité, fréquemment employée, consiste à ne pas lire, mais à affecter arbitrairement la variable avant la boucle. Arbitrairement, pas tout à fait, puisque cette affectation doit avoir pour résultat de provoquer l’entrée obligatoire dans la boucle. L’affectation doit donc faire en sorte que le booléen soit mis à VRAI pour déclencher le premier tour de la boucle. Dans notre exemple, on peut donc affecter Rep avec n’importe quelle valeur, hormis « O » et « N » : car dans ce cas, l’exécution sauterait la boucle, et Rep ne serait pas du tout lue au clavier. Cela donnera par exemple :
Variable Rep en Caractère
Début
Rep ← "X"
Ecrire "Voulez vous un café ? (O/N)"
TantQue Rep <> "O" et Rep <> "N"
 Lire Rep
FinTantQue
Fin
Cette manière de procéder est à connaître, car elle est employée très fréquemment.
Il faut remarquer que les deux solutions (lecture initiale de Rep en dehors de la boucle ou affectation de Rep) rendent toutes deux l’algorithme satisfaisant, mais présentent une différence assez importante dans leur structure logique.
En effet, si l’on choisit d’effectuer une lecture préalable de Rep, la boucle ultérieure sera exécutée uniquement dans l’hypothèse d’une mauvaise saisie initiale. Si l’utilisateur saisit une valeur correcte à la première demande de Rep, l’algorithme passera sur la boucle sans entrer dedans.
En revanche, avec la deuxième solution (celle d’une affectation préalable de Rep), l’entrée de la boucle est forcée, et l’exécution de celle-ci, au moins une fois, est rendue obligatoire à chaque exécution du programme. Du point de vue de l’utilisateur, cette différence est tout à fait mineure ; et à la limite, il ne la remarquera même pas. Mais du point de vue du programmeur, il importe de bien comprendre que les cheminements des instructions ne seront pas les mêmes dans un cas et dans l’autre.
Pour terminer, remarquons que nous pourrions peaufiner nos solutions en ajoutant des affichages de libellés qui font encore un peu défaut. Ainsi, si l’on est un programmeur zélé, la première solution (celle qui inclut deux lectures de Rep, une en dehors de la boucle, l’autre à l’intérieur) pourrait devenir :
Variable Rep en Caractère
Début
Ecrire "Voulez vous un café ? (O/N)"
Lire Rep
TantQue Rep <> "O" et Rep <> "N"
 Ecrire "Vous devez répondre par O ou N. Recommencez"
 Lire Rep
FinTantQue
Ecrire "Saisie acceptée"
Fin
Quant à la deuxième solution, elle pourra devenir :
Variable Rep en Caractère
Début
Rep  "X"
Ecrire "Voulez vous un café ? (O/N)"
TantQue Rep <> "O" et Rep <> "N"
 Lire Rep
 Si Rep <> "O" et Rep <> "N" Alors
 Ecrire "Saisie Erronée, Recommencez"
 FinSi
FinTantQue
Fin
3.16.2.	Exercices
Exercice 5.1
Ecrire un algorithme qui demande à l’utilisateur un nombre compris entre 1 et 3 jusqu’à ce que la réponse convienne.
Exercice 5.2
Ecrire un algorithme qui demande un nombre compris entre 10 et 20, jusqu’à ce que la réponse convienne. En cas de réponse supérieure à 20, on fera apparaître un message : « Plus petit ! », et inversement, « Plus grand ! » si le nombre est inférieur à 10.
Exercice 5.3
Ecrire un algorithme qui demande un nombre de départ, et qui ensuite affiche les dix nombres suivants. Par exemple, si l'utilisateur entre le nombre 17, le programme affichera les nombres de 18 à 27.
Exercice 5.4
Ecrire un algorithme qui demande un nombre de départ, et qui ensuite écrit la table de multiplication de ce nombre, présentée comme suit (cas où l'utilisateur entre le nombre 7) :
Table de 7 :
7 x 1 = 7
7 x 2 = 14
7 x 3 = 21
…
7 x 10 = 70
3.17.	Boucler en comptant / Compter en bouclant
Dans le dernier exercice, vous avez remarqué qu’une boucle pouvait être utilisée pour augmenter la valeur d’une variable. Cette utilisation des boucles est très fréquente, et dans ce cas, il arrive très souvent qu’on ait besoin d’effectuer un nombre déterminé de passages. Or, a priori, notre structure TantQue ne sait pas à l’avance combien de tours de boucle elle va effectuer (puisque le nombre de tours dépend de la valeur d’un booléen).
C’est pourquoi une autre structure de boucle est à notre disposition :
Variable Truc en Entier
Début
Truc ← 0
TantQue Truc < 15
 Truc ← Truc + 1
 Ecrire "Passage numéro : ", Truc
FinTantQue
Fin
Equivaut à :
Variable Truc en Entier
Début
Pour Truc ← 1 à 15
 Ecrire "Passage numéro : ", Truc
 Truc Suivant
Fin
Insistons : la structure « Pour … Suivant » n’est pas du tout indispensable ; on pourrait fort bien programmer toutes les situations de boucle uniquement avec un « Tant Que ». Le seul intérêt du « Pour » est d’épargner un peu de fatigue au programmeur, en lui évitant de gérer lui-même la progression de la variable qui lui sert de compteur (on parle d’incrémentation). 
Dit d’une autre manière, la structure « Pour … Suivant » est un cas particulier de TantQue : celui où le programmeur peut dénombrer à l’avance le nombre de tours de boucles nécessaires.
Il faut noter que dans une structure « Pour … Suivant », la progression du compteur est laissée à votre libre disposition. Dans la plupart des cas, on a besoin d’une variable qui augmente de 1 à chaque tour de boucle. On ne précise alors rien à l’instruction « Pour » ; celle-ci, par défaut, comprend qu’il va falloir procéder à cette incrémentation de 1 à chaque passage, en commençant par la première valeur et en terminant par la deuxième.
Mais si vous souhaitez une progression plus spéciale, de 2 en 2, ou de 3 en 3, ou en arrière, de –1 en –1, ou de –10 en –10, ce n’est pas un problème : il suffira de le préciser à votre instruction « Pour » en lui rajoutant le mot « Pas » et la valeur de ce pas (Le « pas » dont nous parlons, c’est le « pas » du marcheur, « step » en anglais).
Naturellement, quand on stipule un pas négatif dans une boucle, la valeur initiale du compteur doit être supérieure à sa valeur finale si l’on veut que la boucle tourne. Dans le cas contraire, on aura simplement écrit une boucle dans laquelle le programme ne rentrera jamais.
Nous pouvons donc maintenant donner la formulation générale d’une structure « Pour ». Sa syntaxe générale est :
Pour Compteur ← Initial à Final Pas ValeurDuPas
…
Instructions
…
Compteur suivant
Les structures TantQue sont employées dans les situations où l’on doit procéder à un traitement systématique sur les éléments d’un ensemble dont on ne connaît pas d’avance la quantité, comme par exemple :
•	le contrôle d’une saisie
•	la gestion des tours d’un jeu (tant que la partie n’est pas finie, on recommence)
•	la lecture des enregistrements d’un fichier de taille inconnue.
Les structures Pour sont employées dans les situations où l’on doit procéder à un traitement systématique sur les éléments d’un ensemble dont le programmeur connaît d’avance la quantité.
3.18.	Boucles dans des boucles
De même que les poupées russes contiennent d’autres poupées russes, de même qu’une structure SI … ALORS peut contenir d’autres structures SI … ALORS, une boucle peut tout à fait contenir d’autres boucles.
Variables Truc, Trac en Entier
Début
Pour Truc  1 à 15
 Ecrire "Il est passé par ici"
 Pour Trac  1 à 6
 Ecrire "Il repassera par là"
 Trac Suivant
Truc Suivant
Fin
Dans cet exemple, le programme écrira une fois "il est passé par ici" puis six fois de suite "il repassera par là", et ceci quinze fois en tout. A la fin, il y aura donc eu 15 x 6 = 90 passages dans la deuxième boucle (celle du milieu), donc 90 écritures à l’écran du message « il repassera par là ». Notez la différence marquante avec cette structure :
Variables Truc, Trac en Entier
Début
Pour Truc  1 à 15
 Ecrire "Il est passé par ici"
Truc Suivant
Pour Trac  1 à 6
 Ecrire "Il repassera par là"
Trac Suivant
Fin
Ici, il y aura quinze écritures consécutives de "il est passé par ici", puis six écritures consécutives de "il repassera par là", et ce sera tout.
Des boucles peuvent donc être imbriquées (cas n°1) ou successives (cas n°2). Cependant, elles ne peuvent jamais, au grand jamais, être croisées. Cela n’aurait aucun sens logique, et de plus, bien peu de langages vous autoriseraient ne serait-ce qu’à écrire cette structure aberrante.
Variables Truc, Trac en Entier
Pour Truc  …
 instructions
 Pour Trac  …
 instructions
Truc Suivant
 instructions
 Trac Suivant



Pourquoi imbriquer des boucles ? 
Pour la même raison qu’on imbrique des tests. La traduction en bon français d’un test, c’est un « cas ». Un « cas » (par exemple, « est-ce un homme ou une femme ? ») peut très bien se subdiviser en d’autres cas (« a-t-il plus ou moins de 18 ans ? »).
De même, une boucle, c’est un traitement systématique, un examen d’une série d’éléments un par un (par exemple, « prenons tous les employés de l’entreprise un par un »).
On peut imaginer que pour chaque élément ainsi considéré (pour chaque employé), on doit procéder à un examen systématique d’autre chose (« prenons chacune des commandes que cet employé a traitées »). Voilà un exemple typique de boucles imbriquées : on devra programmer une boucle principale (celle qui prend les employés un par un) et à l’intérieur, une boucle secondaire (celle qui prend les commandes de cet employé une par une).
Dans la pratique de la programmation, la maîtrise des boucles imbriquées est nécessaire, même si elle n’est pas suffisante. 
3.19.	Choses à éviter
Examinons l’algorithme suivant :
Variable Truc en Entier
Début 
Pour Truc  1 à 15
 Truc  Truc * 2
 Ecrire "Passage numéro : ", Truc
Truc Suivant
Fin
Vous remarquerez que nous faisons ici gérer « en double » la variable Truc, ces deux gestions étant contradictoires. D’une part, la ligne
Pour…
Augmente la valeur de Truc de 1 à chaque passage. D’autre part la ligne
Truc ← Truc * 2
Double la valeur de Truc à chaque passage. Il va sans dire que de telles manipulations perturbent complètement le déroulement normal de la boucle, et sont causes, sinon de plantages, tout au moins d’exécutions erronées.
 
3.19.1.	Exercices
Exercice 5.5
Ecrire un algorithme qui demande un nombre de départ, et qui calcule la somme des entiers jusqu’à ce nombre. Par exemple, si l’on entre 5, le programme doit calculer :
1 + 2 + 3 + 4 + 5 = 15
NB : on souhaite afficher uniquement le résultat, pas la décomposition du calcul.
Exercice 5.6
Ecrire un algorithme qui demande un nombre de départ, et qui calcule sa factorielle.
NB : la factorielle de 8, notée 8 !, vaut
1 x 2 x 3 x 4 x 5 x 6 x 7 x 8
Exercice 5.7
Ecrire un algorithme qui demande successivement 20 nombres à l’utilisateur, et qui lui dise ensuite quel était le plus grand parmi ces 20 nombres :
Entrez le nombre numéro 1 : 12
Entrez le nombre numéro 2 : 14
etc.
Entrez le nombre numéro 20 : 6
Le plus grand de ces nombres est : 14
Modifiez ensuite l’algorithme pour que le programme affiche de surcroît en quelle position avait été saisie ce nombre :
C’était le nombre numéro 2
Exercice 5.8
Réécrire l’algorithme précédent, mais cette fois-ci on ne connaît pas d’avance combien l’utilisateur souhaite saisir de nombres. La saisie des nombres s’arrête lorsque l’utilisateur entre un zéro.
Exercice 5.9
Lire la suite des prix (en euros entiers et terminée par zéro) des achats d’un client. Calculer la somme qu’il doit, lire la somme qu’il paye, et simuler la remise de la monnaie en affichant les textes "10 Euros", "5 Euros" et "1 Euro" autant de fois qu’il y a de coupures de chaque sorte à rendre.
Exercice 5.10
Écrire un algorithme qui permette de connaître ses chances de gagner au tiercé, quarté, quinté et autres impôts volontaires.
On demande à l’utilisateur le nombre de chevaux partants, et le nombre de chevaux joués. Les deux messages affichés devront être :
Dans l’ordre : une chance sur X de gagner
Dans le désordre : une chance sur Y de gagner
X et Y nous sont donnés par la formule suivante, si n est le nombre de chevaux partants et p le nombre de chevaux joués (on rappelle que le signe ! signifie "factorielle", comme dans l'exercice 5.6 ci-dessus) :
X = n ! / (n - p) !
Y = n ! / (p ! * (n – p) !)
NB : cet algorithme peut être écrit d’une manière simple, mais relativement peu performante. Ses performances peuvent être singulièrement augmentées par une petite astuce. Vous commencerez par écrire la manière la plus simple, puis vous identifierez le problème, et écrirez une deuxième version permettant de le résoudre.
3.20.	Tableaux
Les tableaux sont d’une grande utilité, Imaginons que dans un programme, nous ayons besoin simultanément de 12 valeurs (par exemple, des notes pour calculer une moyenne). Evidemment, la seule solution dont nous disposons à l’heure actuelle consiste à déclarer douze variables, appelées par exemple Notea, Noteb, Notec, etc. Bien sûr, on peut opter pour une notation un peu simplifiée, par exemple N1, N2, N3, etc. Mais cela ne change pas fondamentalement notre problème, car arrivé au calcul, et après une succession de douze instructions « Lire » distinctes, cela donnera obligatoirement une atrocité du genre :
Moy  (N1+N2+N3+N4+N5+N6+N7+N8+N9+N10+N11+N12)/12
C’est tout de même grandement laborieux. Et pour un peu que nous soyons dans un programme de gestion avec quelques centaines ou quelques milliers de valeurs à traiter, alors là c’est le suicide direct.
Cerise sur le gâteau, si en plus on est dans une situation on l’on ne peut pas savoir d’avance combien il y aura de valeurs à traiter, là on est carrément cuits.
C’est pourquoi la programmation nous permet de rassembler toutes ces variables en une seule, au sein de laquelle chaque valeur sera désignée par un numéro. En bon français, cela donnerait donc quelque chose du genre « la note numéro 1 », « la note numéro 2 », « la note numéro 8 ». C’est largement plus pratique, vous vous en doutez.
Un ensemble de valeurs portant le même nom de variable et repérées par un nombre, s’appelle un tableau, ou encore une variable indicée.
Le nombre qui, au sein d’un tableau, sert à repérer chaque valeur s’appelle l’indice.
Chaque fois que l’on doit désigner un élément du tableau, on fait figurer le nom du tableau, suivi de l’indice de l’élément, entre parenthèses.
 
3.20.1.	Annotation et utilisation algorithmique
Dans notre exemple, nous créerons donc un tableau appelé Note. Chaque note individuelle (chaque élément du tableau Note) sera donc désignée Note(0), Note(1), etc. Eh oui, attention, les indices des tableaux commencent généralement à 0, et non à 1.
Un tableau doit être déclaré comme tel, en précisant le nombre et le type de valeurs qu’il contiendra (la déclaration des tableaux est susceptible de varier d'un langage à l'autre. Certains langages réclament le nombre d'éléments, d'autre le plus grand indice... C'est donc une affaire de conventions).
En nous calquant sur les choix les plus fréquents dans les langages de programmations, nous déciderons ici arbitrairement et une bonne fois pour toutes que :
•	les "cases" sont numérotées à partir de zéro, autrement dit que le plus petit indice est zéro.
•	lors de la déclaration d'un tableau, on précise la plus grande valeur de l'indice (différente, donc, du nombre de cases du tableau, puisque si on veut 12 emplacements, le plus grand indice sera 11). Au début, ça déroute, mais vous verrez, avec le temps, on se fait à tout, même au pire.
Tableau Note(11) en Entier
On peut créer des tableaux contenant des variables de tous types : tableaux de numériques, bien sûr, mais aussi tableaux de caractères, tableaux de booléens, tableaux de tout ce qui existe dans un langage donné comme type de variables. 
Par contre, hormis dans quelques rares langages, on ne peut pas faire un mixage de types différents de valeurs au sein d’un même tableau.
L’énorme avantage des tableaux, c’est qu’on va pouvoir les traiter en faisant des boucles. Par exemple, pour effectuer notre calcul de moyenne, cela donnera par exemple :
Tableau Note(11) en Numérique
Variables Moy, Som en Numérique
Début
Pour i  0 à 11
 Ecrire "Entrez la note n°", i
 Lire Note(i)
i Suivant
Som  0
Pour i ← 0 à 11
 Som  Som + Note(i)
i Suivant
Moy  Som / 12
Fin
NB : On a fait deux boucles successives pour plus de lisibilité, mais on aurait tout aussi bien pu n’en écrire qu’une seule dans laquelle on aurait tout fait d’un seul coup.
Remarque générale : l’indice qui sert à désigner les éléments d’un tableau peut être exprimé directement comme un nombre en clair, mais il peut être aussi une variable, ou une expression calculée.
Dans un tableau, la valeur d’un indice doit toujours :
•	être égale au moins à 0 (dans quelques rares langages, le premier élément d’un tableau porte l’indice 1). Mais comme je l'ai déjà écrit plus haut, nous avons choisi ici de commencer la numérotation des indices à zéro, comme c’est le cas en langage C et en Visual Basic. Donc attention, Truc(6) est le septième élément du tableau Truc !
•	être un nombre entier Quel que soit le langage, l’élément Truc(3,1416) n’existe jamais.
•	être inférieure ou égale au nombre d’éléments du tableau (moins 1, si l’on commence la numérotation à zéro). Si le tableau Bidule a été déclaré comme ayant 25 éléments, la présence dans une ligne, sous une forme ou sous une autre, de Bidule(32) déclenchera automatiquement une erreur.
Si l’on est dans un langage où les indices commencent à zéro, il faut en tenir compte à la déclaration :
Tableau Note(13) en Numérique
...créera un tableau de 14 éléments, le plus petit indice étant 0 et le plus grand 13.
3.20.2.	Exercices
Exercice 6.1
Ecrire un algorithme qui déclare et remplisse un tableau de 7 valeurs numériques en les mettant toutes à zéro.
Exercice 6.2
Ecrire un algorithme qui déclare et remplisse un tableau contenant les six voyelles de l’alphabet latin.
Exercice 6.3
Ecrire un algorithme qui déclare un tableau de 9 notes, dont on fait ensuite saisir les valeurs par l’utilisateur.
Exercice 6.4
Que produit l’algorithme suivant ?
Tableau Nb(5) en Entier
Variable i en Entier
Début
Pour i  0 à 5
 Nb(i)  i * i
i suivant
Pour i  0 à 5
 Ecrire Nb(i)
i suivant
Fin
Peut-on simplifier cet algorithme avec le même résultat ?
Exercice 6.5
Que produit l’algorithme suivant ?
Tableau N(6) en Entier
Variables i, k en Entier
Début
N(0)  1
Pour k  1 à 6
 N(k)  N(k-1) + 2
k Suivant
Pour i  0 à 6
 Ecrire N(i)
i suivant
Fin
Peut-on simplifier cet algorithme avec le même résultat ?
Exercice 6.6
Que produit l’algorithme suivant ?
Tableau Suite(7) en Entier
Variable i en Entier
Début
Suite(0)  1
Suite(1)  1
Pour i  2 à 7
 Suite(i)  Suite(i-1) + Suite(i-2)
i suivant
Pour i  0 à 7
 Ecrire Suite(i)
i suivant
Fin
Exercice 6.7
Ecrivez la fin de l’algorithme 6.3 afin que le calcul de la moyenne des notes soit effectué et affiché à l’écran.
3.20.3.	Tableaux dynamiques
Il arrive fréquemment que l’on ne connaisse pas à l’avance le nombre d’éléments que devra comporter un tableau. Bien sûr, une solution consisterait à déclarer un tableau gigantesque (10 000 éléments, pourquoi pas, au diable les varices) pour être sûr que « ça rentre ». Mais d’une part, on n’en sera jamais parfaitement sûr, d’autre part, en raison de l’immensité de la place mémoire réservée – et la plupart du temps non utilisée, c’est un gâchis préjudiciable à la rapidité, voire à la viabilité, de notre algorithme.
Aussi, pour parer à ce genre de situation, a-t-on la possibilité de déclarer le tableau sans préciser au départ son nombre d’éléments. Ce n’est que dans un second temps, au cours du programme, que l’on va fixer ce nombre via une instruction de redimensionnement : Redim.
Notez que tant qu’on n’a pas précisé le nombre d’éléments d’un tableau, d’une manière ou d’une autre, ce tableau est inutilisable.
Exemple : on veut faire saisir des notes pour un calcul de moyenne, mais on ne sait pas combien il y aura de notes à saisir. Le début de l’algorithme sera quelque chose du genre :
Tableau Notes() en Numérique
Variable nb en Numérique
Début
Ecrire "Combien y a-t-il de notes à saisir ?"
Lire nb
Redim Notes(nb-1)
…
Cette technique n’a rien de sorcier, mais elle fait partie de l’arsenal de base de la programmation en gestion.
3.20.3.1.	Exercices
Exercice 6.8
Ecrivez un algorithme permettant à l’utilisateur de saisir un nombre quelconque de valeurs, qui devront être stockées dans un tableau. L’utilisateur doit donc commencer par entrer le nombre de valeurs qu’il compte saisir. Il effectuera ensuite cette saisie. Enfin, une fois la saisie terminée, le programme affichera le nombre de valeurs négatives et le nombre de valeurs positives.
Exercice 6.9
Ecrivez un algorithme calculant la somme des valeurs d’un tableau (on suppose que le tableau a été préalablement saisi).
Exercice 6.10
Ecrivez un algorithme constituant un tableau, à partir de deux tableaux de même longueur préalablement saisis. Le nouveau tableau sera la somme des éléments des deux tableaux de départ.
Tableau 1 :
4	8	7	9	1	5	4	6
Tableau 2 :
7	6	5	2	1	3	7	4
Tableau à constituer :
11	14	12	11	2	8	11	10

Exercice 6.11
Toujours à partir de deux tableaux précédemment saisis, écrivez un algorithme qui calcule le schtroumpf des deux tableaux. Pour calculer le schtroumpf, il faut multiplier chaque élément du tableau 1 par chaque élément du tableau 2, et additionner le tout. Par exemple si l'on a :
Tableau 1 :
4	8	7	12
Tableau 2 :
3	6

Le résultat sera :
3 * 4 + 3 * 8 + 3 * 7 + 3 * 12 + 6 * 4 + 6 * 8 + 6 * 7 + 6 * 12 = 279
Exercice 6.12
Ecrivez un algorithme qui permette la saisie d’un nombre quelconque de valeurs, sur le principe de l’ex 6.8. Toutes les valeurs doivent être ensuite augmentées de 1, et le nouveau tableau sera affiché à l’écran.
Exercice 6.13
Ecrivez un algorithme permettant, toujours sur le même principe, à l’utilisateur de saisir un nombre déterminé de valeurs. Le programme, une fois la saisie terminée, renvoie la plus grande valeur en précisant quelle position elle occupe dans le tableau. On prendra soin d’effectuer la saisie dans un premier temps, et la recherche de la plus grande valeur du tableau dans un second temps.
 
Exercice 6.14
Toujours et encore sur le même principe, écrivez un algorithme permettant, à l’utilisateur de saisir les notes d'une classe. Le programme, une fois la saisie terminée, renvoie le nombre de ces notes supérieures à la moyenne de la classe.
3.21.	Fichiers
Jusqu’à présent, les informations utilisées dans nos programmes ne pouvaient provenir que de deux sources : soit elles étaient inclues dans l’algorithme lui-même, par le programmeur, soit elles étaient entrées en cours de route par l’utilisateur. Mais évidemment, cela ne suffit pas à combler les besoins réels des informaticiens.
Imaginons que l’on veuille écrire un programme gérant un carnet d’adresses. D’une exécution du programme à l’autre, l’utilisateur doit pouvoir retrouver son carnet à jour, avec les modifications qu’il y a apportées la dernière fois qu’il a exécuté le programme. Les données du carnet d’adresse ne peuvent donc être inclues dans l’algorithme, et encore moins être entrées au clavier à chaque nouvelle exécution.
Les fichiers sont là pour combler ce manque. Ils servent à stocker des informations de manière permanente, entre deux exécutions d’un programme. Car si les variables, qui sont des adresses de mémoire vive, disparaissent à chaque fin d’exécution, les fichiers, eux sont stockés sur des périphériques à mémoire de masse (disquette, disque dur, CD Rom…). Les fichiers sont enregistrés sous des lignes successives qui s’appellent enregistrements.
Un fichier ainsi codé sous forme d'enregistrements est appelé un fichier texte.
En fait, entre chaque enregistrement, sont stockés les octets correspondants aux caractères CR (code Ascii 13) et LF (code Ascii 10), signifiant un retour au début de la ligne suivante. Le plus souvent, le langage de programmation, dès lors qu'il s'agit d'un fichier texte, gèrera lui-même la lecture et l'écriture de ces deux caractères à chaque fin de ligne : c'est autant de moins dont le programmeur aura à s'occuper. Le programmeur, lui, n'aura qu'à dire à la machine de lire une ligne, ou d'en écrire une.
Ce type de fichier est couramment utilisé dès lors que l'on doit stocker des informations pouvant être assimilées à une base de données.
Le second type de fichier, se définit a contrario : il rassemble les fichiers qui ne possèdent pas de structure de lignes (d'enregistrement). Les octets, quels qu'ils soient, sont écrits à la queue leu leu. Ces fichiers sont appelés des fichiers binaires. Naturellement, leur structure différente implique un traitement différent par le programmeur. Tous les fichiers qui ne codent pas une base de données sont obligatoirement des fichiers binaires : cela concerne par exemple un fichier son, une image, un programme exécutable, etc. . Il est toujours possible d'opter pour une structure binaire même dans le cas où le fichier représente une base de données.
Autre différence majeure entre fichiers texte et fichiers binaires : dans un fichier texte, toutes les données sont écrites sous forme de... texte. Cela veut dire que les nombres y sont représentés sous forme de suite de chiffres (des chaînes de caractères). Ces nombres doivent donc être convertis en chaînes lors de l'écriture dans le fichier. Inversement, lors de la lecture du fichier, on devra convertir ces chaînes en nombre si l'on veut pouvoir les utiliser dans des calculs. En revanche, dans les fichiers binaires, les données sont écrites à l'image exacte de leur codage en mémoire vive, ce qui épargne toutes ces opérations de conversion.
Ceci a comme autre implication qu'un fichier texte est directement lisible, alors qu'un fichier binaire ne l'est pas (sauf bien sûr en écrivant soi-même un programme approprié). Si l'on ouvre un fichier texte via un éditeur de textes, comme le bloc-notes de Windows, on y reconnaîtra toutes les informations (ce sont des caractères, stockés comme tels). La même chose avec un fichier binaire ne nous produit à l'écran qu'une suite des symboles incompréhensibles.
NB : La notion des fichiers sera approfondie dans la suite de ce cours, soit en initiation à l’algoritmique 2.
3.22.	Procédures et fonctions
3.22.1.	Fonctions personnalisées
Une application, surtout si elle est longue, a toutes les chances de devoir procéder aux mêmes traitements, ou à des traitements similaires, à plusieurs endroits de son déroulement. 
Par exemple, la saisie d’une réponse par oui ou par non (et le contrôle qu’elle implique), peuvent être répétés dix fois à des moments différents de la même application, pour dix questions différentes.
La manière la plus évidente, mais aussi la moins habile, de programmer ce genre de choses, c'est bien entendu de répéter le code correspondant autant de fois que nécessaire. Apparemment, on ne se casse pas la tête : quand il faut que la machine interroge l'utilisateur, on recopie les lignes de codes voulues en ne changeant que le nécessaire, et roule Raoul. Mais en procédant de cette manière, la pire qui soit, on se prépare des lendemains qui déchantent...
D'abord, parce que si la structure d'un programme écrit de cette manière peut paraître simple, elle est en réalité inutilement lourdingue. Elle contient des répétitions, et pour peu que le programme soit énorme, il peut devenir parfaitement illisible. Or, le fait d'être facilement modifiable donc lisible, y compris - et surtout - par ceux qui ne l'ont pas écrit est un critère essentiel pour un programme informatique. Dès que l'on programme non pour soi-même, mais dans le cadre d'une organisation (entreprise ou autre), cette nécessité se fait sentir de manière aiguë. L'ignorer, c'est donc forcément grave.
En plus, à un autre niveau, une telle structure pose des problèmes considérables de maintenance : car en cas de modification du code, il va falloir traquer toutes les apparitions plus ou moins identiques de ce code pour faire convenablement la modification. Et si l'on en oublie une, on a laissé un bug.
Il faut donc opter pour une autre stratégie, qui consiste à séparer ce traitement du corps du programme et à regrouper les instructions qui le composent en un module séparé. Il ne restera alors plus qu'à appeler ce groupe d'instructions (qui n'existe donc désormais qu’en un exemplaire unique) à chaque fois qu’on en a besoin. Ainsi, la lisibilité est assurée ; le programme devient modulaire, et il suffit de faire une seule modification au bon endroit, pour que cette modification prenne effet dans la totalité de l’application.
Le corps du programme s’appelle alors la procédure principale, et ces groupes d’instructions auxquels on a recours s’appellent des fonctions et des sous-procédures (nous verrons un peu plus loin la différence entre ces deux termes).
Reprenons un exemple de question à laquelle l’utilisateur doit répondre par oui ou par non.
Mauvaise Structure :

...
Ecrire "Etes-vous marié ?"
Rep1  ""
TantQue Rep1 <> "Oui" et Rep1 <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Rep1
FinTantQue
...
Ecrire "Avez-vous des enfants ?"
Rep2  ""
TantQue Rep2 <> "Oui" et Rep2 <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Rep2
FinTantQue
...
On le voit bien, il y a là une répétition quasi identique du traitement à accomplir. A chaque fois, on demande une réponse par Oui ou Non, avec contrôle de saisie. La seule chose qui change, c'est l'intitulé de la question, et le nom de la variable dans laquelle on range la réponse. Alors, il doit bien y avoir un truc.
La solution, on vient de le voir, consiste à isoler les instructions demandant une réponse par Oui ou Non, et à appeler ces instructions à chaque fois que nécessaire. Ainsi, on évite les répétitions inutiles, et on a découpé notre problème en petits morceaux autonomes.
Nous allons donc créer une fonction dont le rôle sera de renvoyer la réponse (oui ou non) de l'utilisateur. Ce mot de "fonction", en l'occurrence, ne doit pas nous surprendre : nous savons qu’il y a des fonctions fournies avec le langage, le but d'une fonction était de renvoyer une valeur. Nous allons créer notre propre fonction, que nous appellerons RepOuiNon :
Fonction RepOuiNon() en caractère
Truc  ""
TantQue Truc <> "Oui" et Truc <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Truc
FinTantQue
Renvoyer Truc
Fin
On remarque au passage l’apparition d’un nouveau mot-clé : Renvoyer, qui indique quelle valeur doit prendre la fonction lorsqu'elle est utilisée par le programme. Cette valeur renvoyée par la fonction (ici, la valeur de la variable Truc) est en quelque sorte contenue dans le nom de la fonction lui-même, exactement comme c’était le cas dans les fonctions prédéfinies.
Une fonction s'écrit toujours en-dehors de la procédure principale. Selon les langages, cela peut prendre différentes formes. Mais ce qu'il faut comprendre, c'est que ces quelques lignes de codes sont en quelque sorte des satellites, qui existent en dehors du traitement lui-même. Simplement, elles sont à sa disposition, et il pourra y faire appel chaque fois que nécessaire. Si l'on reprend notre exemple, une fois notre fonction RepOuiNon écrite, le programme principal comprendra les lignes :
Bonne structure :

...
Ecrire "Etes-vous marié ?"
Rep1  RepOuiNon()
...
Ecrire "Avez-vous des enfants ?"
Rep2  RepOuiNon()
...
On a ainsi évité les répétitions inutiles, et si d'aventure, il y avait un bug dans notre contrôle de saisie, il suffirait de faire une seule correction dans la fonction RepOuiNon pour que ce bug soit éliminé de toute l'application. 
Toutefois, les plus sagaces d'entre vous auront remarqué, tant dans le titre de la fonction que dans chacun des appels, la présence de parenthèses. Celles-ci, dès qu'on déclare ou qu'on appelle une fonction, sont obligatoires. Et si vous avez bien compris tout ce qui précède, vous devez avoir une petite idée de ce qu'on va pouvoir mettre dedans...
3.22.2.	Passage d’arguments
Reprenons l’exemple qui précède et analysons-le. On écrit un message à l'écran, puis on appelle la fonction RepOuiNon pour poser une question ; puis, un peu plus loin, on écrit un autre message à l'écran, et on appelle de nouveau la fonction pour poser la même question, etc. C’est une démarche acceptable, mais qui peut encore être améliorée : puisque avant chaque question, on doit écrire un message, autant que cette écriture du message figure directement dans la fonction appelée. Cela implique deux choses :
•	lorsqu’on appelle la fonction, on doit lui préciser quel message elle doit afficher avant de lire la réponse
•	la fonction doit être « prévenue » qu’elle recevra un message, et être capable de le récupérer pour l’afficher.
En langage algorithmique, on dira que le message devient un argument (ou un paramètre) de la fonction. Cela n'est certes pas une découverte pour vous : nous avons longuement utilisé les arguments à propos des fonctions prédéfinies. 
La fonction sera dorénavant déclarée comme suit :
Fonction RepOuiNon(Msg en Caractère) en Caractère
Ecrire Msg
Truc  ""
TantQue Truc <> "Oui" et Truc <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Truc
FinTantQue
Renvoyer Truc
Fin Fonction
Il y a donc maintenant entre les parenthèses une variable, Msg, dont on précise le type, et qui signale à la fonction qu’un argument doit lui être envoyé à chaque appel. Quant à ces appels, justement, ils se simplifieront encore dans la procédure principale, pour devenir :
...
Rep1 ← RepOuiNon("Etes-vous marié ?")
...
Rep2 ← RepOuiNon("Avez-vous des enfants ?")
...
3.22.3.	Sous procédures
Problème, une fonction ne peut renvoyer qu'une seule valeur à la fois.
Alors, pour renvoyer plusieurs valeurs, faute de pouvoir traiter l'affaire par une fonction, devra-t-on en rester au code répétitif dont nous avons de dénoncé si vigoureusement les faiblesses. Heureusement, tout est prévu, il y a une solution. Et celle-ci consiste à utiliser des sous-procédures.
En fait, les fonctions - que nous avons vues - ne sont finalement qu'un cas particulier des sous-procédures - que nous allons voir : celui où doit être renvoyé vers la procédure appelant une valeur et une seule. Dans tous les autres cas (celui où on ne renvoie aucune valeur, comme celui ou en en renvoie plusieurs), il faut donc avoir recours non à la forme particulière et simplifiée (la fonction), mais à la forme générale (la sous-procédure). Le rapport entre fonctions et sous-procédures est donc semblable à celui qui existe entre les boucles Pour et les boucles TantQue : les premières sont un cas particulier des secondes, pour lequel les langages proposent une écriture plus directe.
Parlons donc de ce qui est commun aux sous-procédures et aux fonctions, mais aussi de ce qui les différencie. Voici comment se présente une sous-procédure :
Procédure Bidule( ... )
...
Fin Procédure
Dans la procédure principale, l’appel à la sous-procédure Bidule devient quant à lui :
Appeler Bidule(...)
Établissons un premier état des lieux.
•	Alors qu'une fonction se caractérisait par les mots-clés Fonction ... Fin Fonction, une sous-procédure est identifiée par les mots-clés Procédure ... Fin Procédure
•	Lorsqu'une fonction était appelée, sa valeur (retournée) était toujours affectée à une variable (ou intégrée dans le calcul d'une expression). L'appel à une procédure, lui, est au contraire toujours une instruction autonome. « Exécute la procédure Bidule » est un ordre qui se suffit à lui-même.
•	Toute fonction devait, pour cette raison, comporter l'instruction « Renvoyer ». Pour la même raison, l'instruction « Renvoyer » n'est jamais utilisée dans une sous-procédure. La fonction est une valeur calculée, qui renvoie son résultat vers la procédure principale. La sous-procédure, elle, est un traitement ; elle ne « vaut » rien.
•	Même une fois qu'on a bien compris les trois premiers points, on n'est pas complètement au bout de nos peines.
Reprenons l'exemple que nous avons déjà utilisé plus haut, celui de notre fonction RepOuiNon. Comme nous l'avons vu, rien ne nous empêche de réécrire cette fonction sous la forme d'une procédure (puisqu'une fonction n'est qu'un cas particulier de sous-procédure). Nous laisserons pour l’instant de côté la question de savoir comment renvoyer la réponse (contenue dans la variable Truc) vers le programme principal. En revanche, nous allons déclarer que Msg est un paramètre dont la transmission doit se faire par valeur. Cela donnera la chose suivante :
Procédure RepOuiNon(Msg en Caractère par valeur)
Ecrire Msg
Truc ← ""
TantQue Truc <> "Oui" et Truc <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Truc
FinTantQue
??? Comment transmettre Truc à la procédure appelante ???
Fin Procédure
Quant à l'appel à cette sous-procédure, il pourra prendre par exemple cette forme :
M  "Etes-vous marié ?"
Appeler RepOuiNon(M)
Une conséquence essentielle de tout cela est que si d'aventure la sous-procédure RepOuiNon contenait une instruction qui modifiait le contenu de la variable Msg, cela n'aurait aucune espèce de répercussion sur la procédure principale en général, et sur la variable M en particulier. La sous-procédure ne travaillant que sur une copie de la variable qui a été fournie par le programme principal, elle est incapable, même si on le souhaitait, de modifier la valeur de celle-ci. Dit d'une autre manière, dans une procédure, un paramètre passé par valeur ne peut être qu'un paramètre en entrée.
C'est certes une limite, mais c'est d'abord et avant tout une sécurité : quand on transmet un paramètre par valeur, on est sûr et certain que même en cas de bug dans la sous-procédure, la valeur de la variable transmise ne sera jamais modifiée par erreur (c'est-à-dire écrasée) dans le programme principal.
Admettons à présent que nous déclarions un second paramètre, Truc, en précisant cette fois qu'il sera transmis par référence. Et adoptons pour la procédure l'écriture suivante :
Procédure RepOuiNon(Msg en Caractère par valeur, Truc en Caractère par référence)
Ecrire Msg
Truc  ""
TantQue Truc <> "Oui" et Truc <> "Non"
 Ecrire "Tapez Oui ou Non"
 Lire Truc
FinTantQue
Fin Fonction
L'appel à la sous-procédure deviendrait par exemple :
M  "Etes-vous marié ?"
Appeler RepOuiNon(M, T)
Ecrire "Votre réponse est ", T
3.23.	Notions complémentaires
3.23.1.	Programmation structurée
Dans certains langages (historiquement, ce sont souvent des langages anciens), les lignes de programmation portent des numéros. Et les lignes sont exécutées par la machine dans l’ordre de ces numéros. Jusqu’ici, en soi, pas de problème. Mais l’astuce est que tous ces langages, il existe une instruction de branchement, notée aller à en pseudo-code, instruction qui envoie directement le programme à la ligne spécifiée. Inversement, ce type de langage ne comporte pas d’instructions comme FinTantQue, ou FinSi, qui « ferment » un bloc.
Prenons l’exemple d’une structure « Si … Alors … Sinon »
Programmation Structurée
Si condition Alors
 instructions 1
Sinon
 instructions 2
FinSi

Programmation non structurée
1000 Si condition Alors Aller En 1200
1100 instruction 1
1110 etc.
1120 etc.
1190 Aller en 1400
1200 instruction 2
1210 etc.
1220 etc.
1400 suite de l’algorithme
Un programme écrit dans ce type de langages se présente comme une suite de branchements emmêlés les uns dans les autres. D’une part, on ne peut pas dire que cela favorise la lisibilité du programme. D’autre part, c’est une source importante d’erreurs, car tôt ou tard on oublie un « aller à », ou on met un de trop, etc. A fortiori lorsqu’on complique un algorithme existant, cela peut devenir une jungle inextricable.
A l’inverse, la programmation structurée, surtout si l’on prend soin de rationaliser la présentation en mettant des lignes de commentaires et en pratiquant l’indentation, évite des erreurs, et révèle sa structure logique de manière très claire.
Le danger est que si la plupart des langages de programmation utilisés sont structurés, ils offrent tout de même la plupart du temps la possibilité de pratiquer la programmation non structurée. Dans ce cas, les lignes ne sont pas désignées par des numéros, mais certaines peuvent être repérées par des noms (dits « étiquettes ») et on dispose d’une instruction de branchement.
Une règle d’hygiène absolue est de programmer systématiquement de manière structurée, sauf impératif contraire fixé par le langage (ce qui est aujourd'hui de plus en plus rare).
Autrement dit, même quand un langage vous offre une possibilité de faire des entorses à la programmation structurée, il ne faut s’en saisir sous aucun prétexte.
3.23.2.	Interprétation et compilation
Avec ce paragraphe, on sort un peu de l’algorithmique proprement dite pour entrer dans le domaine plus technique de la réalisation pratique. Ou, si l’on préfère, ces dernières lignes sont l’apothéose, le bouquet final, l’extase ultime, la consécration grandiose, de ce cours.
Jusqu’ici, nous avons travaillé sur la première étape de la réalisation d’un programme : la rédaction de l'algorithme.
 
En fait, si l’algorithme est bien écrit, sans faute logique, l’étape suivante ne doit normalement poser aucun problème conceptuel. Il n'y a plus qu'à effectuer une simple traduction.
 
A partir de là, le travail du programmeur est virtuellement terminé (en réalité, il reste tout de même une inévitable phase de tests, de corrections, etc., qui s'avère souvent très longue). Mais en tout cas, pour l’ordinateur, c’est là que les ennuis commencent. En effet, aucun ordinateur n’est en soi apte à exécuter les instructions telles qu’elles sont rédigées dans tel ou tel langage ; l’ordinateur, lui, ne comprend qu’un seul langage, qui est un langage codé en binaire (à la rigueur en hexadécimal) et qui s’appelle le langage machine (ou assembleur).
 
C’est à cela que sert un langage : à vous épargner la programmation en binaire et vous permettre de vous faire comprendre de l’ordinateur d’une manière (relativement) lisible.
C’est pourquoi tout langage, à partir d’un programme écrit, doit obligatoirement procéder à une traduction en langage machine pour que ce programme soit exécutable.
Il existe deux stratégies de traduction, ces deux stratégies étant parfois disponibles au sein du même langage.
•	le langage traduit les instructions au fur et à mesure qu’elles se présentent. Cela s’appelle la compilation à la volée, ou l’interprétation.
•	le langage commence par traduire l’ensemble du programme en langage machine, constituant ainsi un deuxième programme (un deuxième fichier) distinct physiquement et logiquement du premier. Ensuite, et ensuite seulement, il exécute ce second programme. Cela s’appelle la compilation
Il va de soi qu’un langage interprété est plus maniable : on peut exécuter directement son code - et donc le tester - au fur et à mesure qu’on le tape, sans passer à chaque fois par l’étape supplémentaire de la compilation. Mais il va aussi de soi qu’un programme compilé s’exécute beaucoup plus rapidement qu’un programme interprété : le gain est couramment d’un facteur 10, voire 20 ou plus.
Toute application destinée à un usage professionnel (ou même, tout simplement sérieux) est forcément une application compilée.
3.23.3.	Programmation récursive
La programmation des fonctions personnalisées a donné lieu à l'essor d’une logique un peu particulière, adaptée en particulier au traitement de certains problèmes mathématiques (ou de jeux) : la programmation récursive. Pour vous expliquer de quoi il retourne, nous allons reprendre un exemple cher à vos cœurs : le calcul d’une factorielle.
Rappelez-vous : la formule de calcul de la factorielle d’un nombre n s’écrit :
N ! = 1 x 2 x 3 x … x n
Nous avions programmé cela aussi sec avec une boucle Pour.. Mais une autre manière de voir les choses, ni plus juste, ni moins juste, serait de dire que quel que soit le nombre n :
n ! = n x (n-1) !
En bon français : la factorielle d’un nombre, c’est ce nombre multiplié par la factorielle du nombre précédent. Encore une fois, c’est une manière ni plus juste ni moins juste de présenter les choses ; c’est simplement une manière différente.
Si l’on doit programmer cela, on peut alors imaginer une fonction Fact, chargée de calculer la factorielle. Cette fonction effectue la multiplication du nombre passé en argument par la factorielle du nombre précédent. Et cette factorielle du nombre précédent va bien entendu être elle-même calculée par la fonction Fact.
Autrement dit, on va créer une fonction qui pour fournir son résultat, va s’appeler elle-même un certain nombre de fois. C’est cela, la récursivité.
Toutefois, il nous manque une chose pour finir : quand ces auto-appels de la fonction Fact vont-ils s’arrêter ? Cela n’aura-t-il donc jamais de fin ? On s’arrête quand on arrive au nombre 1, pour lequel la factorielle est par définition 1.
Cela produit l’écriture suivante, un peu déconcertante certes, mais parfois très pratique :
Fonction Fact (N en Numérique)
Si N = 0 alors
 Renvoyer 1
Sinon
 Renvoyer Fact(N-1) * N
Finsi
Fin Fonction
Vous remarquerez que le processus récursif remplace en quelque sorte la boucle, c’est-à-dire un processus itératif. Vous remarquerez aussi qu’on traite le problème à l’envers : on part du nombre, et on remonte à rebours jusqu’à 1 pour pouvoir calculer la factorielle. 
Cet effet de rebours est caractéristique de la programmation récursive.
Pour conclure sur la récursivité, trois remarques fondamentales.
•	la programmation récursive, pour traiter certains problèmes, est très économique pour le programmeur ; elle permet de faire les choses correctement, en très peu d'instructions.
•	en revanche, elle est très dispendieuse de ressources machine. Car à l’exécution, la machine va être obligée de créer autant de variables temporaires que de « tours » de fonction en attente.
•	Last but not least, et c’est le gag final, tout problème formulé en termes récursifs peut également être formulé en termes itératifs. Donc, si la programmation récursive peut faciliter la vie du programmeur, elle n’est jamais indispensable.

 
DEUXIEME PARTIE : BREVE HISTOIRE DE LA PROGRAMMATION
Chapitre quatrième : Programmation en ligne de temps
4.1.	Jalons de l’informatique
La première machine programmable (c’est-à-dire machine dont les possibilités changent quand on modifie son "programme") est probablement le métier à tisser de Jacquard, qui a été réalisé en 1801. La machine utilisait une suite de cartons perforés. Les trous indiquaient le motif que le métier suivait pour réaliser un tissage ; avec des cartes différentes le métier produisait des tissages différents. Cette innovation a été ensuite améliorée par Herman Hollerith d'IBM pour le développement de la fameuse carte perforée d'IBM.
En 1936, la publication de l'article fondateur de la science informatique On Computable Numbers with an Application to the Entscheidungs problem par Alan Mathison turing allait donner le coup d'envoi à la création de l'ordinateur programmable. Il y présente sa machine de Turing, le premier calculateur universel programmable, et invente les concepts et les termes de programmation et de programme.
Les premiers programmes d'ordinateurs étaient réalisés avec un fer à souder et un grand nombre de tubes à vide (plus tard, des transistors). Les programmes devenant plus complexes, cela est devenu presque impossible, parce qu'une seule erreur rendait le programme entier inutilisable. Avec les progrès des supports de données, il devient possible de charger le programme à partir de cartes perforées, contenant la liste des instructions en code binaire spécifique à un type d'ordinateur particulier. 
La puissance des ordinateurs augmentant, on les utilisa pour faire les programmes, les programmeurs préférant naturellement rédiger du texte plutôt que des suites de 0 et de 1, à charge pour l'ordinateur d'en faire la traduction lui-même. Avec le temps, de nouveaux langages de programmation sont apparus, faisant de plus en plus abstraction du matériel sur lequel devaient tourner les programmes. Ceci apporte plusieurs facteurs de gains : ces langages sont plus faciles à apprendre, un programmeur peut produire du code plus rapidement, et les programmes produits peuvent tourner sur différents types de machines.
Un processeur est un composant électronique qui effectue des opérations en suivant des instructions. En 2009 les processeurs peuvent exécuter plusieurs centaines de millions d'instructions par seconde.
Un programme est typiquement composé d'un ensemble de procédures et de fonctions. Une procédure est une suite d'instructions destinées à réaliser une opération - par exemple trier une liste. Une fonction est une suite d'instructions destinées à produire un résultat - par exemple un calcul.
En mathématiques et en informatique, un algorithme est une suite d'opérations de calcul qui, réalisées de façon systématique, permettent d'obtenir un résultat. La suite d'opération peut être exécutée par un humain ou par un appareil informatique. Les programmes informatiques contiennent de nombreux algorithmes.
Un compilateur est un programme qui crée un programme exécutable en transformant les instructions d'un programme source écrit dans un langage de programmation donné en les instructions machines équivalentes d'un processeur donné.
Un assembleur est un compilateur simplifié, qui transforme des instructions machine écrites sous forme de mots clés (langage d'assemblage) en les suites de bits correspondantes.
Un interprète est un programme qui exécute les instructions machines équivalentes aux instructions d'un programme source formulées dans un langage de programmation donné.
Un langage de programmation est un ensemble de règles d'écriture de programmes source - vocabulaire et règles de ponctuation - qui permettent d'exprimer des programmes qui pourront être transformés en instruction machines à l'aide des algorithmes contenus dans un compilateur ou un interprète. Les instructions qu'un processeur exécute sont des suites de bits difficiles à comprendre et à manipuler par un humain, mais faciles à automatiser par des circuits électroniques. 
L'écriture du programme dans un langage de programmation donné est destinée à faciliter le travail du programmeur.
Un logiciel est un bien composé d'un ou de plusieurs programmes, associés à un contrat de licence par lequel l'auteur octroie au détenteur le droit d'utiliser le programme.
Un bug est un défaut de construction dans un programme. Les instructions que l'appareil informatique exécutent ne correspondent pas à ce qui est attendu, ce qui provoque des dysfonctionnements et des pannes.
4.2.	Logiciels
Dans la majorité des cas, on achète des programmes (logiciels) tout faits qui correspondent plus ou moins au besoin :
	Traitement de texte - P.A.O : avec mise en page, justification, numérotation chapitres-pages, table des matières, dictionnaire...
	Tableur : tableau de nombres à 2 dimensions et calculs
	Base de données : ensemble de fiches (nom, adresse...) et recherche par rubrique, publipostage...
	C.A.O, Dessin par ordinateur : propre, modification aisée, archivage...
	Gestion : paye, facturation, stock...
	Communication : transfert de programmes par modem et ligne téléphonique, serveur minitel...
Un Intégré regroupe plusieurs de ces possibilités.
Soit on achète un logiciel général : très bon niveau, parfaitement testé, documentation, formation... mais trop général (fonctions inutiles, fonctions utiles avec trop de paramètres ou difficilement accessibles). Soit on fait (ou fait faire) un logiciel particulier : plus pratique, mais plus hasardeux (erreurs, SAV, doc...). Le cahier des charges doit être très précis.
4.3.	Organisation de l’ordinateur
	Multiposte : plusieurs consoles sur un même ordinateur (CPU puissant, tout est partageable)
	Réseau : plusieurs CPU et MC non partageable (sauf réseau de multipostes), MdM et périphériques partageables ou locaux.

4.4.	Langage de programmation
Un ordinateur est une machine bête, ne sachant qu'obéir, et à très peu de choses :
	addition, soustraction, multiplication en binaire, uniquement sur des entiers,
	sortir un résultat ou lire une valeur binaire (dans une mémoire par exemple),
	comparer des nombres.
Sa puissance vient du fait qu'il peut être PROGRAMME, c'est à dire que l'on peut lui donner, à l'avance, la séquence (la suite ordonnée) des ordres à effectuer l'un après l'autre. Le grand avantage de l'ordinateur est sa rapidité. Par contre, c'est le programmeur qui doit TOUT faire. L'ordinateur ne comprenant que des ordres codés en binaire (le langage machine), des langages dits "évolués" ont été mis au point pour faciliter la programmation.
Le PASCAL, créé par WIRTH au début des années 70, possède des instructions assez claires (si vous comprenez l'anglais), et favorise une approche méthodique et disciplinée (on dit "structurée").
Le PASCAL est un langage compilé, c'est à dire qu'il faut :
	entrer un texte dans l'ordinateur (à l'aide d'un programme appelé EDITEUR),
	le traduire en langage machine (c'est à dire en codes binaires compréhensibles par l'ordinateur) : c'est la compilation et éventuellement l'édition de liens (LINK),
	l'exécuter.
Contrairement à un basic interprété, l'exécution sera beaucoup plus rapide puisqu'il n'y a plus de traduction à effectuer.
Bien que le langage soit normalisé, un certain nombre de points dépendent de la machine et du compilateur utilisé (par exemple comment appeler le compilateur). Ces indications ne seront pas données ici. Si vous avez le choix, il est conseillé d’utiliser TURBO PASCAL, le plus pratique d'emploi (en particulier parce qu'il possède son propre éditeur de texte).
4.5.	Langage Pascal
4.5.1.	Mots reservés en PASCAL
	AND - ARRAY - ASM
	BEGIN
	CASE - CONST - CONSTRUCTOR
	DESTRUCTOR - DIV - DO - DOWNTO
	ELSE - END - EXPORTS
	FILE - FOR - FUNCTION
	GOTO
	IF - IMPLEMENTATION - IN - INHERITED - INLINE - INTERFACE
	LABEL - LIBRARY
	MOD
	NIL - NOT
	OBJECT - OF - OR
	PACKED - PROCEDURE - PROGRAM
	RECORD - REPEAT
	SET - SHL - SHR - STRING
	THEN - TO - TYPE
	UNIT - UNTIL - USES
	VAR
	WHILE - WITH
	XOR
 
4.5.2.	Opérateurs
	Opérateurs mathématiques
Opérateur	Signification
+	Addition - Union
-	Soustraction - Complément
*	Multiplication - Intersection
/	Division
div	Quotient de la division entière
mod	Modulus: c'est le reste de la division entière
=	Egalité



Opérateurs prioritaires : *, /, div et mod.
Opérateurs secondaires : + et -.
Vous pouvez utiliser des parenthèses.
	Opérateurs relationnels
Opérateur	Signification
<	Inférieur strict
<=	Inférieur ou égal - Inclus
>	Supérieur strict
>=	Supérieur ou égal - Contient
<>	Différent








	Opérateurs logiques
Opérateur	Signification
AND	Le "et" logique des maths
OR	Le "ou"
XOR	Le "ou" exclusif
NOT	Le "non"






Opérateur ultra-prioritaire : NOT.
Opérateur semi-prioritaire : AND.
Opérateurs non prioritaires : OR et XOR.
Priorité des opérateurs
• Niveau 1 : NOT.
• Niveau 2 : *, /, mod, div, AND.
• Niveau 3 : +, -, OR, XOR.
• Niveau 4 : =, <, >, <=, >=, <>.
4.5.3.	Programmer en PASCAL
	Premier petit programme
Program AfficheNom;
Var nom : String;
BEGIN
Write('Entrez votre nom : ');
ReadLn(nom);
WriteLn('Votre nom est ', nom);
ReadLn;
END.
Un programme PASCAL est composé d'une entête, des déclarations et des instructions (délimitées par BEGIN et END. ).
	PROGRAM cercle (input,output);	(* entête *)
	VAR perimetre,diametre : REAL;	(* déclarations *)
	BEGIN
		readln(diametre);	(* instruction *)
		perimetre := 3.141592 * diametre; (* instruction *)
		writeln(diametre,perimetre)	(* instruction *)
	END.
L'entête est composée du mot PROGRAM, suivi du nom du programme (cercle), et d'indications sur les Entrées/Sorties (ici le clavier et l'écran).
4.5.4.	Structure d’un programme écrit en PASCAL
La partie déclarative de notre programme est limitée à la déclaration de deux variables (mot clef VAR). Une variable est une "case" mémoire de l'ordinateur, à laquelle on donne ici un nom. Chaque case peut contenir une valeur. On a précisé ici que nos deux variables PERIMETRE et DIAMETRE contiendraient des réels. Les types simples connus en PASCAL sont : REAL, INTEGER (entier naturel), CHAR (contient UN est un seul caractère), et BOOLEAN (booléen, c.a.d qui peut valoir soit TRUE (vrai) soit FALSE (faux). 
En TURBO PASCAL, les entiers admissibles sont compris entre -32768 et +32767. Dans tous les PASCALs on possède la variable prédéclarée MAXINT qui donne le plus grand entier admissible. Les réels doivent être compris en TURBO entre + et -1.7E37 (c.a.d 1,7 fois 10 puissance 37), avec 11 chiffres significatifs. La virgule décimale est toujours représentée par un point en informatique.
Un identificateur (tout nom que vous choisissez : variable, programme...) peut être formé de lettres (A à Z), de chiffres et (pas sur toutes les versions de PASCAL) du signe _ (souligné). TURBO PASCAL accepte des noms de 127 caractères maximum, certains PASCAL sont plus limités (31 caractères par ex). Le premier caractère doit être une lettre. 
Par exemple, VALEUR1 ou PREM_VALEUR sont possibles mais pas 1ERE_VALEUR. En PASCAL les minuscules sont traitées comme des majuscules (SURface et surFACE désignent la même case mémoire). 
Les accents et autres ‘ç’ ne sont pas autorisés (var diamètre : real est interdit à cause de l'accent). Un blanc dans un identificateur est également interdit (utilisez _ pour séparer des mots dans un même identificateur).
Toute variable utilisée dans un programme doit être déclarée. Ceci évite la plupart des erreurs de frappe, et rend le programme plus compréhensible.
Les instructions de notre programme sont :
	lecture sur le clavier : le programme s'arrête, attend que l'on donne une valeur à l'aide du clavier, met cette valeur dans la case DIAMETRE et continue le programme lorsque l'on appuie sur la touche "ENTREE" ou "RETURN".
	calcul et affectation : on multiplie le contenu de la case DIAMETRE par PI, et on met le résultat dans la case PERIMETRE.
Le := symbolise une flèche à gauche. Ce n'est PAS une égalité au sens mathématique, mais la copie d'une valeur dans une mémoire.
	écriture sur l'écran : on affiche sur l'écran le contenu des case DIAMETRE (que l'on connaissait puisque nous l'avions donné) et PERIMETRE (qui nous intéresse un peu plus). Ce programme affiche donc deux chiffres. Il serait plus parlant d'afficher également des commentaires par l'instruction :
writeln ('Diamètre : ',diametre,', Périmètre : ',perimetre)
Les textes doivent être entourés de cotes ('). 
Les majuscules/minuscules sont significatives. 
Pour afficher une apostrophe utiliser deux côtes ('l''exemple'). Pour sauter une ligne utiliser WRITELN seul.
Les instructions doivent toujours être séparées par des ";" ("séparées", pas "terminées"). 
Le fait de passer à la ligne n'est interprété par l'ordinateur que comme un blanc. On aurait donc pu écrire notre programme sur une seule ligne (peut-être un peu longue pour l'éditeur). 
Le programme doit toujours se terminer par un point (.).
On peut insérer des remarques dans le programme (qui ne seront pas lues par le compilateur) en les entourant par (* et *) ou { et }. On ne peut en standard pas imbriquer des commentaires. Les commentaires peuvent faire plus d'une ligne, ceci permet de supprimer momentanément une partie d'un programme.
Chaque identificateur est séparé du suivant par un blanc. On considère comme un blanc : plusieurs blancs, un retour à la ligne, un commentaire.
4.5.4.1.	Exercices 
Faire un programme demandant le prix unitaire HT d'un article et sa quantité, puis qui affiche : le total Hors Taxes, le montant de la TVA (pour un taux de 18,6 %) et le total TTC.
4.5.5.	Constantes
Nous avons déjà utilisé des VARIABLES (on donne un nom à une mémoire). Mais on peut également utiliser des CONSTANTES, qui sont des valeurs qui restent fixes tout au long du programme et pour chaque exécution. On déclare les constantes avant de déclarer les variables, par : CONST nom=valeur
CONST taux_tva=18.6
MAXINT (plus grand entier possible) est une constante prédéfinie.
On peut également avoir des constantes de type "chaîne de caractères" :
PROGRAM bonjour(output); { on n'a pas besoin ici du clavier }
 CONST message1='salut, ça va ?';
 message2='moi ça baigne';
 BEGIN
	writeln(message1);
	writeln(message2) (* notez l'absence de ; devant le END *)
 END.
Le type de la constante est déterminé automatiquement par le compilateur (entier si nombre sans point, réel si nombre avec point, caractères si entre cotes).
Remarque :
1: on peut toujours utiliser un entier à la place d'un réel mais pas l'inverse.
2: si on utilise un point décimal, il FAUT l'encadrer de chiffres (0.3 et non .3, 10 ou 10.0 et non 10.)
4.5.6.	Instructions d’affectation
On appelle AFFECTATION la mise d'une valeur dans une variable. Celle-ci peut être sous forme directe (A:=B) ou sous forme d'un calcul (A:=B*C). Le signe := représente une flèche à gauche, et signifie "mettre la VALEUR à droite du := dans la mémoire désignée à gauche" (mettre le contenu de B dans A ou mettre le résultat du calcul (contenu de B) fois (contenu de C) dans A). Une affectation du type B*C:=A est donc IMPOSSIBLE.
Une affectation ne peut se faire qu'entre une variable et une expression de même type (si A est réel, impossible de faire A:='xyz'). La seule exception est de mettre un entier dans un réel (le .0 est rajouté automatiquement), mais l'inverse est impossible directement. Soient I entier et X réel, pour mettre X dans I il faut utiliser I:=ROUND(X) (arrondi) ou I:=TRUNC(X) (partie entière).
On peut également utiliser des affectations et expressions booléennes. Par exemple, en ayant déclaré :
VAR test:boolean;
a,b:real;
on peut écrire :
TEST:=(A<B)and(A>0)
4.5.7.	Types de variables standards simples et opérateurs associés
Tous ces types, excepté les réels, sont dits "énumérés".
4.5.7.1.	Entiers
Déclaration : VAR variable1,variable2,...,variableN : INTEGER;
Opérations sur entiers : + - * div (division) mod (reste de la division). 
Elles sont toutes à résultat entier, et nécessitent deux arguments entiers.
Les entiers sont compris entre -MAXINT et +MAXINT qui est une constante standard prédéfinie (sa valeur dépend par contre du compilateur, 32767 en TURBO).
4.5.7.2.	Réels
Déclaration : VAR liste de variables : REAL;
Opérations : + - * /
Quand une opération comprend un argument réel et un entier, le résultat est réel. / donne toujours un résultat réel, même si les deux arguments sont entiers.
* et / sont de priorité supérieure à + et -, mais entre * et / tout dépend du compilateur (en général de gauche à droite). En cas d'ambiguïté, utilisez des parenthèses (il n'y a aucun inconvénient à mettre plus de parenthèses que nécessaire).
 
Exemples d'expressions numériques (soit A=3, B=4, C=2):
A+B/C = A+(B/C) = 5
(A+B)/C = 3.5
A/B*C = (A/B)*C (1.5) dans certains cas, A/(B*C) (0.375) dans d'autres
A/BC = valeur de A sur valeur de la variable de nom BC et non A sur B*C
B*A-5*C = (B*A)-(5*C) = 2
4.5.7.3.	Booléens
Déclaration : VAR liste de variables : BOOLEAN;
Ces variables peuvent prendre soit la valeur TRUE (vrai), soit la valeur FALSE (faux).
Opérations booléennes : AND, OR, NOT, et (non standard) XOR (ou exclusif). 
Ces opérations nécessitent des arguments booléens.
Opérations à valeur booléenne : > (supérieur), < (inf), >= (sup ou égal), <=, = (égal), <> (différent). Ces opérations comparent tous éléments de type simple (les 2 arguments doivent être de même type, sauf entiers et réels qui peuvent être comparés entre eux), et renvoient un booléen. Les caractères sont comparés suivant l'ordre du code ASCII.
AND (et), OR (ou), NOT (non), sont de priorité supérieure aux précédents et ne peuvent opérer que sur des booléens : A>B et C doit être écrit : (A>B) and (A>C). Les parenthèses sont obligatoires pour ne pas faire en premier B and A.
4.5.7.4.	Caractères
Déclaration : VAR liste de variables : CHAR;
Ces variables contiennent UN caractère. 
Ceux-ci sont classés suivant un ordre précis: le code ASCII qui suit l'ordre suivant :
	les chiffres '0' à '9' par ordre croissant
	les majuscules 'A' à 'Z' par ordre alphabétique
	les minuscules 'a' à 'z'
Dans le code ASCII, chaque caractère possible a un numéro de code. Par exemple A a pour code 65. En déclarant C comme variable caractère, on peut mettre le signe A dans C par C:='A' ou C:=CHR(65). Dans le premier cas, il faut mettre les cotes pour différencier 'A' de la variable A. Pour mettre une cote dans C, on peut faire C:=chr(39) ou C:='''' : la 1ère cote pour dire qu'il va y avoir un caractère, les 2 suivantes qui symbolisent la cote (car une seule cote voudrait dire fin du caractère), la dernière qui signifie fin du caractère.
 
4.5.8.	Fonctions standards
On peut utiliser comme une variable des fonctions (qui peuvent soit être connues par le compilateur, soit définies par vous-même). Une fonction est un "module" ou "routine" qui renvoie une valeur au programme. Par exemple, A:=sqrt(B*C) met dans A la racine carrée de B fois C. B*C est appelé ARGUMENT de la fonction.
Les principales fonctions standards connues par tous les compilateurs sont :
ABS : renvoie la valeur absolue SIN : sinus
SQR : renvoie le carré ARCTAN : arc tangente
SQRT : racine carrée EX : exponentielle
COS : cosinus LN : log népérien
SUCC : variable énumérée suivante PRED : précédent
ROUND : arrondi à l'entier le plus proche
TRUNC : partie entière (permet de mettre un réel dans un entier:
trunc(4.5)=4)
Comme toute variable, une fonction possède un type (entier, réel,...) défini, et ne peut donc être utilisée que comme une variable de ce type.
4.5.9.	Instructions
On appelle "instruction simple" soit :
	une affectation
	un appel à une procédure (une procédure est un ensemble d'instructions regroupées sous un nom, par exemple READLN)
	une structure de contrôle (voir plus bas);
On appelle "instruction composée" le regroupement de plusieurs instructions sous la forme :
BEGIN instruction1;instruction2; ... ;instructionN END
Remarque :
On ne met pas de ; après BEGIN ni avant END (puisque le ; sépare deux instructions). Par contre, si l'instruction composée est SUIVIE d'une autre instruction, on mettra un ; après le END .
La lisibilité du programme sera meilleure en mettant une instruction par ligne, et en décalant à droite les instructions comprises entre un begin et un end.
On appelle "instruction" une instruction soit simple soit composée.
4.5.10.	Structure de controle
Nos connaissances actuelles ne nous permettent pas de faire des programmes utilisant la capacité de l'ordinateur de répéter rapidement et sans erreur beaucoup de calculs. Nous allons donc remédier immédiatement à cela. Chaque structure de contrôle forme une instruction (qui peut donc être utilisée dans une autre structure de contrôle).
4.5.10.1.	Boucle WHILE … DO (tant que - faire)
Structure: WHILE expression booléenne DO instruction
Elle permet de répéter l'instruction tant que l'expression (ou la variable) booléenne est vraie.
PROGRAM racine_a_deux_decimales(input,output);
	VAR nombre,racine:REAL;
	begin
		writeln('entrez un réel entre 0 et 10');
		readln(nombre);
		racine:=0;
		WHILE racine*racine < nombre DO racine:=racine+0.01;
		writeln('la racine de ',nombre,' vaut à peu près',racine)
	END.
Il faut noter que si l'expression booléenne est fausse dès le début, l'instruction n'est jamais exécutée (ici si NOMBRE=0). Attention, Pascal n'initialise pas automatiquement les variables à 0, c'est à dire que sans l'instruction RACINE:=0 le programme risquerait de donner une réponse fausse (RACINE valant n'importe quoi, il sera en général très supérieur à la racine cherchée).
On ne peut répéter qu'UNE seule instruction. Mais celle-ci peut être simple (comme dans l'exemple précédent) ou composée (begin - end).
EXERCICE (ex_puiss) faire un programme qui affiche les puissances de 2 jusqu'à une valeur maxi donnée par l'utilisateur (par multiplication successive par 2).
4.5.10.2.	Boucle REPEAT - UNTIL (répéter - jusqu'à ce que)
structure :	REPEAT
			instruction1;
			instruction2;
			...etc...
			instructionN
		UNTIL condition
Les N instructions sont répétées jusqu'à ce que la condition soit vérifiée. Même si la condition est vraie dès le début, elles sont au moins exécutées une fois.
PROGRAM jeu_simpliste(input,output);
 VAR a:integer;
begin
		writeln('entrez le nombre 482');
		REPEAT
			readln(a)
 		UNTIL a=482;
		writeln('c''est gentil de m''avoir obéi')
end.
Quelle que soit la valeur initiale de A (même 482), la question sera au moins posée une fois (plus si vous désobéissez).
EXERCICE (ex_jeu). Faites un jeu qui demande de trouver le nombre entre 0 et 10 choisi par l'ordinateur (en comptant les coups). On utilisera la fonction RANDOM(N) (non standard, disponible en TURBO PASCAL) qui renvoie un entier entre 0 et N-1 compris, par l'instruction VALEUR_CHOISIE:=RANDOM(11).
4.5.10.3.	Boucle FOR – DO (Pour – Faire)
FOR variable_énumérée:=valeur_début TO valeur_fin DO instruction
La variable_énumérée (non réelle) prend la valeur_début, et l'instruction est exécutée. Puis elle est incrémentée (on passe à la suivante, c.a.d si elle est entière on ajoute 1), et ce jusqu'à valeur_fin (compris).
L'instruction sera donc exécutée (valeur_fin - valeur_début + 1) fois. Si valeur_ fin est inférieur à valeur_début l'instruction n'est jamais exécutée. Cette forme de boucle est utilisée chaque fois que l'on connaît le nombre de boucles à effectuer.
On peut utiliser un pas dégressif en remplaçant TO par DOWNTO.
ex: for lettre:='Z' downto 'A' do writeln(lettre)
Ecrit l'alphabet à l'envers(en déclarant LETTRE du type CHAR)
La variable_énumérée peut être utilisée (mais pas modifiée) dans l'instruction (simple ou composée). Elle est souvent appelée "indice" de la boucle. Sa valeur est perdue dès que l'on sort de la boucle.
EXERCICE (ex_moy) Faire un programme qui calcule la moyenne de N nombres. N doit être demandé par un READLN. (Initialiser une variable à 0, y ajouter progressivement chaque note puis diviser par N).
4.5.10.4.	Instruction IF - THEN - ELSE (si - alors - sinon)
IF condition THEN instruction1 (CAS 1) ou
IF condition THEN instruction1 ELSE instruction2 (CAS 2)
Si la condition est vraie, alors on exécute l'instruction1 (simple ou composée). Sinon, on passe à la suite (cas 1), ou on exécute l'instruction2 (cas 2).
Remarquez qu'il n'y a pas de ; devant le ELSE.
EXERCICE (ex_jeu_bis) modifier le jeu précédent (ex_jeu) en aidant le joueur (en précisant si c'est plus ou c'est moins).
L'instruction2 peut être composée ou entre autres être une instruction IF :
IF condition1 THEN instruction1
 ELSE IF condition2 THEN instruction2
 ELSE IF condition3 THEN instruction3
 ......
ELSE instructionN
Un ELSE correspond toujours au dernier IF rencontré (mais dont on n'a pas encore utilisé le ELSE).
IF cond1 then if cond2 then inst1 {cond1 et cond2}
		else inst2 {cond1 et pas cond2}
		else if cond3 then inst3 {pas cond1 mais cond3}
		else inst4 {ni cond1 ni cond3}
Si on désire autre chose, utiliser BEGIN et END :
IF cond1 THEN	begin
			if cond2 then inst1
		end (* le prochain ELSE se rapporte à COND1 puisque
l'instruction (composée) suivant THEN est terminée *)
ELSE inst2
4.5.10.5.	Structure CASE - OF (cas - parmi)
Elle évite d'utiliser une trop grande suite de ELSE IF.
	CASE expression OF {regardez bien où il y a les ;}
		liste_de_cas1:instruction1;
		liste_de_cas2:instruction2;
		.....
		liste_de_casN:instructionN
	END
L'instruction i sera exécutée si l'expression appartient à la liste_de_cas i. Les autres ne seront pas exécutées (on passe directement au END). L'expression doit être de type énuméré (pas de réels).
En TURBO PASCAL, on accepte une liste_de_cas particulière qui est ELSE (et doit être placée en dernier), pour prévoir le cas où expression n'appartient à aucun des cas cités au-dessus. En MS-PASCAL on utilise de même OTHERWISE.
CASE a*b OF (* avec a et b déclarés entiers *)
	0 : writeln('un des nombres est nul');
	1,10,100,1000,10000 :
	writeln('le produit est une puissance de 10');
	(* 100000 est impossible en TURBO car supérieur à MAXINT
*)
 END
Attention certains compilateurs n'acceptent pas de passer sur un CASE avec une valeur prévue dans aucune liste de cas.
EXERCICE (ex_calc) faire un programme simulant une calculatrice 4 opérations en utilisant CASE pour le choix de l'opération à effectuer.
4.5.11.	Tableaux
4.5.11.1.	Tableaux unidimensionnels
On a souvent besoin de regrouper dans une seule variable (et donc un seul nom) plusieurs variables (exemple 3 coordonnées d'un même vecteur). On utilise pour cela les TABLEAUX. La manière la plus simple des les définir est :
VAR nom_tableau : ARRAY [type_index] OF type_composantes
CONST dimension=3;
VAR vecteur1,vecteur2 : ARRAY [1..dimension] OF REAL
On peut utiliser le tableau complet (vecteur1:=vecteur2) pour l'affectation uniquement (vecteur1+vecteur2 est impossible directement). Mais on peut également accéder aux différentes composantes par un index (si vecteur1 est le vecteur unitaire porté par Y, alors VECTEUR1[1]=0 ,VECTEUR1[2]=1, VECTEUR1[3]=0 ).
l'index peut être variable:
PROGRAM heures(input,output);
 TYPE tj=(lundi,mardi,mercredi,jeudi,vendredi,samedi,dimanche);
 VAR jour:tj;
nb_heures_cours:ARRAY[tj] OF integer;
begin
{il faudrait ici entrer les nombres d'heures de cours par jour}
FOR jour:=lundi TO samedi DO writeln(nb_heures_cours[jour])
end.
On peut également définir un TYPE tableau, par exemple :
TYPE typheures=ARRAY[tj] OF integer;
VAR nb_heures_cours:typheures;
EXERCICE (moy a) Ecrire le programme qui lit une liste de N nombres, calcule et affiche la moyenne puis l'écart entre chaque note et cette moyenne.
EXERCICE (rot.b) Ecrire le programme qui lit une liste de N nombres, la décale d'un cran vers le haut (le 1er doit se retrouver en dernier) l'affiche puis la décale vers le bas.
EXERCICE (clas.c) Classer automatiquement une liste de n entiers par ordre croissant puis décroissant.
4.5.11.2.	Chaines de caracteres
On appelle chaîne de caractères une suite de caractères regroupés dans une seule variable. En PASCAL standard il faut la déclarer comme ARRAY[1..nbcar] OF CHAR. Les tests sont possibles entre chaines (test suivant l'ordre ASCII du 1er caractère, puis automatiquement du 2ème, etc).
ex : 'aaz'<'aba' 'aa '<'aaa' 'ZZZ'<'aaa' (majuscules)
On peut également utiliser ces tableaux dans READLN et WRITELN.
Mais en général, les compilateurs possèdent des types plus puissants, associés à des fonctions et procédures non standard. En Turbo on déclare une chaîne par STRING[nbcar]. Une fonction utile est alors LENGTH(variable_string) qui donne la longueur de la chaîne (inférieure ou égale à la dimension déclarée).
EXERCICE (str) Ecrire un programme qui détermine le nombre et les positions d'une chaîne dans une autre (ex ON dans FONCTION : en position 2 et 7).
4.5.11.3.	Tableaux de tableaux
On peut faire des tableaux avec des composantes de tous types, y compris de tableaux. On peut voir une matrice comme un tableau de lignes qui sont-elles même des tableaux de composantes (exemple matrice 5 lignes, 10 colonnes):
TYPE 	ligne=array[1..10] of real;
		mat=array[1..5] of ligne;
l'écriture TYPE mat=array[1..5] of array[1..10] of real
ou même TYPE mat=array[1..5,1..10] of real
Sont strictement équivalentes (sauf si la définition du type ligne est nécessaire pour d'autres variables).
Soit la déclaration
	VAR 	m1,m2:mat;
		i,j:integer;
On peut écrire :
m1[i,j]:=10 {affectation de la valeur 10 en ligne i, colonne j}
m1[i]:=m1[i+1] {copie complète de la ligne i+1 sur la ligne i}
	m2:=m1 {copie de la matrice complète}
RAPPEL: READLN et WRITELN ne s'appliquent qu'a des variables simples prédéfinies (c.a.d les composantes, si celles-ci sont réelles, entières, chaînes ou booléennes).
EXERCICE (mat) faire le calcul de multiplication d'une matrice (M lignes, L col) par (L lignes, N col) (résultat M lignes, N col).
4.5.12.	Enregistrements
Dans un tableau, tous les constituants doivent être semblables. Ce n'est pas le cas des enregistrements, qui sont des variables composées de plusieurs variables (ou CHAMPS) de types différents.
	Declaration
Structure d'une déclaration d'enregistrement :
VAR nom_variable :RECORD champ1:type ; champ2:type ;.... END
ou
TYPE nom_type = RECORD champ1:type ; champ2:type ;.... END
TYPE date = RECORD
jour:1..31;
mois:1..12;
an:1980..1999
 END;
facture = RECORD
reference:integer;
jour:date; {enregistrement d'enregistrement}
client:string[100];
total_HT:real
 END;
 VAR date1,date2:date;
comptes:array[1..100] of facture;
fact:facture;

 
Références
	https://fr.wikipedia.org/wiki/Test_(informatique)
	https://web.maths.unsw.edu.au/~lafaye/CCM/pascal/pascintro.htm
	http://docplayer.fr/47392862-Les-bases-du-langage-pascal.html
	http://informatiqued003.blogspot.com/2013/11/pascal.html
	https://www.lamsade.dauphine.fr/~mayag/Chapitre_1_Introduction_Algorithmique.pdf
	https://perso.liris.cnrs.fr/pierre-antoine.champin/enseignement/algo/cours/algo/intro.html
	https://cours-examens.org/images/An_2017_1/Etudes_superieures/Informatique/Autres/Introduction-l_Algorithmique-.pdf
	https://www.youtube.com/watch?v=Ezh9S2nbBqo
	https://www.youtube.com/watch?v=ZuxcqHVxW5I
	https://www.youtube.com/watch?v=z9WVh2K0svU
	https://web.maths.unsw.edu.au/~lafaye/CCM/algo/algointro.htm
	https://pixees.fr/informatiquelycee/n_site/nsi_prem_intro_algo.html
	http://cours.pise.info/algo/introduction.htm
	https://www.cours-gratuit.com/cours-algorithme/initiation-a-l-algorithmique-gratuit
	https://uclouvain.be/cours-2020-linfo1103
	https://www.amazon.fr/Introduction-%C3%A0-lalgorithmique-Thomas-Cormen/dp/2100031287
	http://profmath.uqam.ca/~fabiennevenant/MAT3812/hiver13/MAT3812--13/algo.pdf
	http://igm.univ-mlv.fr/~alabarre/teaching/intro/cours01-handout.pdf
	https://www.enib.fr/~tisseau/pdf/course/introductionPaper.pdf
	https://www.lri.fr/~hivert/COURS/CFA-L3/00-Intro.pdf
	https://www.irif.fr/~jep//PostScript/Introduction.ps.gz
	https://www.est-usmba.ac.ma/ALGORITHME/co/module_ALGORITHME_3.html
	https://www.ulaval.ca/les-etudes/cours/repertoire/detailsCours/ift-1701-introduction-a-lalgorithmique-et-a-la-programmation.html
	http://www.jybaudot.fr/Programmation/algo.html
	https://www.technologuepro.com/informatique/chap1_algorithme.htm
	https://dorbec.users.greyc.fr/M1102/1102-intro-algo-prog.pdf
	http://vanconingsloo.be/les-cours/bacbes/ipro/introduction-a-lalgorithmique/
	https://openclassrooms.com/fr/courses/1467201-algorithmique-pour-lapprenti-programmeur
	https://www.univ-irem.fr/IMG/pdf/Malika_polycop_sujet.pdf
	https://fr.wikiversity.org/wiki/Algorithmique/Introduction
	https://www.courspdf.net/programmation/algorithme/372-formation-initiation-algorithmique
	http://foad.ugb.sn/course/view.php?id=267
	http://tecfaetu.unige.ch/staf/staf-i/lattion/staf2x/CoursSTAF2X.pdf
	http://www.linguist.univ-paris-diderot.fr/~amsili/Ens07/td1_algo.pdf
	https://www.researchgate.net/publication/331977076_Initiation_a_l'algorithmique_et_a_la_programmation_en_Pascal
	https://www.apmep.fr/IMG/pdf/Atelier_JN_Marseille_13_P1-36.pdf
	https://www.cours-gratuit.com/cours-algorithme/cours-algorithmique-et-programmation-pascal-en-pdf
	https://www.researchgate.net/publication/331977076_Initiation_a_l'algorithmique_et_a_la_programmation_en_Pascal
	https://www.edjet.com/scorm-content/edjet-prod-uploads/d9840bc6d2bc0fe0ccc6c9fc79e7335b74999508/fd14dbc729d136edcaf5107aead6733e.pdf
	http://www.info.univ-angers.fr/~basseur/Algo/introAlgo1314.pdf
	https://www.courspdf.net/programmation/pascal/373-formation-introduction-turbo-pascal
	http://univ-nktt.yolasite.com/resources/Les%20algo_secrets_de_la_programmation.pdf
	https://fr.wikipedia.org/wiki/Pascal_(langage)
	https://www.coursexercices.com/PDF_Cours_Exercices_Telecharger.php?q=langage+pascal+site+du+zero
	https://nanopdf.com/download/tp-informatique-1-introduction-a-turbo-pascal-1-notion-dalgorithme_pdf
	https://data.bnf.fr/fr/11941547/pascal__langage_de_programmation_/





 
Table des matières

PREMIERE PARTIE : L’ALGORITHMIQUE	1
Chapitre premier : Concepts fondamentaux	1
1.1.	Programmation	1
1.2.	Programme	1
1.2.1.	Programme source	1
1.2.2.	Programme objet ou binaire	1
1.3.	Langage de programmation	2
1.4.	Création des programmes	2
1.5.	Vocabulaire de programmation	3
1.6.	Ecriture d’un programme	4
1.7.	Exécution	5
1.7.1.	Compilateur	5
1.7.2.	Interpréteur	5
1.8.	Algorithme	6
1.9.	Algorithmique	7
1.9.1.	Étude formelle	8
1.9.2.	Structures algorithmiques	8
1.9.2.1.	Structures de contrôle et structure des données	8
1.9.2.2.	Correction, complétude, terminaison	9
1.9.2.3.	Approches pratiques	9
1.9.3.	Exemples d’algorithmes, de problèmes, d'applications ou domaines d'application		10
1.10.	Organigramme de programmation	12
Chapitre deuxième : Traitement de l’information-Symboles de documentation et conventions applicables aux données, aux organigrammes de programmation et d’analyse, aux schémas des réseaux de programmes et des ressources de système.	13
2.1. Norme ISO	13
2.2. Organigramme	13
2.2.1.	Objet et domaine d’application	14
2.2.2.	Définitions	14
2.2.3.	Organigramme des données	14
2.2.4.	Organigramme d’analyse	15
2.3.	Schéma de réseau de programme	15
2.4.	Schéma des ressources de système	15
2.5.	Symboles	16
2.5.1.	Symboles de données	16
2.5.2.	Symboles spécifiques	16
2.5.3.	Symboles de traitement	18
2.5.4.	Symboles de représentation des lignes (symboles linéaires)	21
2.6.	Utilisation simple des symboles	22
2.6.1.	Différentes structures	23
2.7.	Mise en place des problèmes informatiques en ordinogramme	23
2.7.1.	Exemple d’un ordinogramme classique	24
2.8.	Transformation du code source	25
2.8.1.	Compilation	25
2.8.2.	Interprétation	25
2.8.3.	Avantages, inconvénients	25
2.8.4.	Appellation impropre	26
2.8.5.	Test du programme	26
2.8.6.	Techniques de programmation	26
Chapitre troisième : Introduction à l’algorithmique	27
3.1.	Bases de l’algorithme	27
3.2.	Algorithme et programmation	28
3.3.	Conventions d’écriture d’un algorithme	29
3.4.	Variables	29
3.4.1.	Utilité d’une variable	29
3.4.2.	Déclaration des variables	30
3.4.2.1.	Types numériques classiques	30
3.4.2.2.	Autres types numériques	31
3.4.2.3.	Type alphanumérique	31
3.4.2.4.	Type booléen	32
3.5.	Instructions d’affectation	32
3.5.1.	Syntaxe et signification	32
3.5.2.	Ordre des instructions	34
3.5.3.	Exercices	36
3.6.	Expressions et opérateurs	37
3.6.1.	Opérateurs numériques :	38
3.6.2.	Opérateur alphanumérique : &	38
3.6.3.	Opérateurs logiques (ou booléens) :	39
3.6.4.	Remarques	39
3.7.	Ecriture et lecture	40
3.7.1.	Exercices	41
3.8.	Tests	42
3.9.	Conditions	43
3.9.1.	Exercices	44
3.10.	Conditions composées	45
3.10.1.	Exercices	46
3.11.	Tests imbriqués	46
3.11.1.	Exercices	48
3.12.	Aiguillage et la gare de tri	48
3.13.	Variables booléennes	50
3.14.	Logique	50
3.14.1.	Entre ‘ET’ et ‘OU’	50
3.14.2.	Exercices	52
3.15.	Style	53
3.15.1.	Exercices	54
3.16.	Boucles	56
3.16.1.	Importance de la boucle	56
3.16.2.	Exercices	59
3.17.	Boucler en comptant / Compter en bouclant	60
3.18.	Boucles dans des boucles	61
3.19.	Choses à éviter	63
3.19.1.	Exercices	64
3.20.	Tableaux	65
3.20.1.	Annotation et utilisation algorithmique	66
3.20.2.	Exercices	67
3.20.3.	Tableaux dynamiques	69
3.20.3.1.	Exercices	69
3.21.	Fichiers	71
3.22.	Procédures et fonctions	72
3.22.1.	Fonctions personnalisées	72
3.22.2.	Passage d’arguments	75
3.22.3.	Sous procédures	76
3.23.	Notions complémentaires	78
3.23.1.	Programmation structurée	78
3.23.2.	Interprétation et compilation	79
3.23.3.	Programmation récursive	80
DEUXIEME PARTIE : BREVE HISTOIRE DE LA PROGRAMMATION	82
Chapitre quatrième : Programmation en ligne de temps	82
4.1.	Jalons de l’informatique	82
4.2.	Logiciels	83
4.3.	Organisation de l’ordinateur	84
4.4.	Langage de programmation	84
4.5.	Langage Pascal	85
4.5.1.	Mots reservés en PASCAL	85
4.5.2.	Opérateurs	86
4.5.3.	Programmer en PASCAL	87
4.5.4.	Structure d’un programme écrit en PASCAL	87
4.5.4.1.	Exercices	89
4.5.5.	Constantes	89
4.5.6.	Instructions d’affectation	89
4.5.7.	Types de variables standards simples et opérateurs associés	90
4.5.7.1.	Entiers	90
4.5.7.2.	Réels	90
4.5.7.3.	Booléens	91
4.5.8.	Fonctions standards	92
4.5.9.	Instructions	92
4.5.10.	Structure de controle	92
4.5.10.1.	Boucle WHILE … DO (tant que - faire)	93
4.5.10.2.	Boucle REPEAT - UNTIL (répéter - jusqu'à ce que)	93
4.5.10.3.	Boucle FOR – DO (Pour – Faire)	94
4.5.10.4.	Instruction IF - THEN - ELSE (si - alors - sinon)	94
4.5.10.5.	Structure CASE - OF (cas - parmi)	95
4.5.11.	Tableaux	96
4.5.11.1.	Tableaux unidimensionnels	96
4.5.11.2.	Chaines de caracteres	97
4.5.11.3.	Tableaux de tableaux	97
4.5.12.	Enregistrements	98
Références	99
Table des matières	102
ANNEXES	- 0 -

 



ANNEXES
 
CORRECTIONS DES EXERCICES

Program Exercice1;
Var Nombre : Integer;
Begin
Write('Entrez un entier pas trop grand : ');
Readln(Nombre);
if Nombre < 100 then WriteLn(Nombre, ' est inférieur à cent.') else
WriteLn(Nombre, ' est supérieur ou égal à cent.');
End.

Program Exercice2;
Var Nombre : Integer;
Begin
Write('Entrez un entier pas trop grand : ');
Readln(Nombre) ;
if Nombre < 100 then
begin
WriteLn(Nombre, ' est inférieur à cent.');
end
else
begin
WriteLn(Nombre, ' est supérieur ou égal à cent.');
end;
End.
Program Exercice4;
Var i : Integer;
Begin
Randomize;
i := random(100);
if i < 50 then WriteLn ( i, ' est inférieur à 50.')
else if i < 73 then WriteLn ( i, ' est supérieur ou égal à 50, et inférieur à 73.')
else WriteLn ( i, ' est supérieur ou égal à 73.')
End.
Program Exercice5;
Var Age : Integer;
Begin
Write('Entrez votre âge : ');
Readln(Age);
case Age of
18 : WriteLn('La majorité, pile-poil !');
0..17 : WriteLn('Venez à moi, les petits enfants...');
60..99 : WriteLn('Les infirmières vous laissent jouer sur l''ordinateur à votre âge ?!!!')
else WriteLn('Vous êtes d''un autre âge...');
end ;
End.
Program Exercice6;
Var i : Integer;
Begin
For i := 100 downto 0 do
begin
WriteLn ('Valeur de i : ', i );
end;
End.
Program Exercice7;
Var i : Integer;
Begin
Repeat
Inc(i);
Writeln ('Boucle itérée ', i, ' fois.');
until i > 20 ;
End.
Program Exercice8;
Var
CodeCorrect : Boolean;
Essai : String;
Const
LeVraiCode = 'password';
Begin
CodeCorrect := False;
While not CodeCorrect do
begin
Write('Entrez le code secret : ');
Readln(Essai);
if Essai = LeVraiCode then CodeCorrect := True;
end ;
End.
Program Arret;
Var i, x : Integer;
Begin
x := 0 ;
Repeat
Inc(i);
Break;
x := 50;
until i > 10;
WriteLn(i);
WriteLn(x);
End.

Program Exercice10;
Uses Crt;
Var a, b, c : Real;
Procedure Maths;
Begin
a := a + 10;
b := sqrt(a);
c := sin(b);
End;
BEGIN
ClrScr;
Write('Entrez un nombre :');
ReadLn(a);
repeat
Maths;
Writeln(c);
until KeyPressed;
END.

Program Exercice11;
Uses Crt;
Procedure Maths (Param : Real);
Begin
WriteLn('Procédure de calcul. Veuillez patienter.');
Param := Sin(Sqrt(Param + 10));
WriteLn(Param);
End;
Var Nombre : Real;
BEGIN
ClrScr;
Write('Entrez un nombre :');
ReadLn(Nombre);
Maths(Nombre);
ReadLn;
END.

Program Exercice12;
Uses Crt;
Procedure Saisie (var Nom : String);
Begin
Write('Entrez votre nom : ');
ReadLn(Nom);
End;
Procedure Affichage (Info : String);
Begin
WriteLn('Voici votre nom : ', Info);
End;
Var Chaine : String;
BEGIN
ClrScr;
Saisie(Shaine) ;
Affichage(Chaine) ;
END.
Program Exercice13;
Uses Crt;
Function Puissance (i, j : Integer) : Integer;
Var Res, a : Integer ;
Begin
Res := 1;
for a := 1 to j do Res := Res * i;
Puissance := Res;
End;
Var Resultat, x, n : Integer;
BEGIN
Write('Entrez un nombre : ');
ReadLn(x);
Write('Entrez un exposant : ');
ReadLn(n);
Resultat := Puissance(x,n);
WriteLn(Resultat);
ReadLn;
END.
Program Exercice14;
Uses Crt;
Var i, f : Integer;
BEGIN
for i := 1 to 20 do
begin
for f := 500 to 1000 do Sound(f);
Delay(10);
end;
Nosound;
END.
Program Exercice15;
Uses
Crt, Dos;
Var
f : Text;
Nom : String;
Choix : Char;
Procedure Lecture;
Begin
Append(f);
Readln(f,nom);
Writeln(nom);
End;
BEGIN
Clrscr;
Assign(f,'init.txt');
Rewrite(f);
Write('Entrez un nom d''utilisateur : ');
Readln(Nom);
Nom := 'Dernier utilisateur : ' + Nom;
Writeln(f,Nom) ;
Close(f);
Write('Voulez-vous lire le fichier init.txt ? [O/N] ');
Choix := ReadKey;
if (UpCase(Choix) = 'O') then Lecture;
END.
Program Exercice16 ;
Uses
Crt, Dos;
Var
f : Text;
s : String ;
BEGIN
Assign(f,'c:\autoexec.bat');
Reset(f);
Writeln('Affichage du contenu du fichier AUTOEXEC.BAT : ');
while not Eof(f) do
begin
ReadLn(f,s);
WriteLn(s);
end;
END.
Exercice 1.1
Après La valeur des variables est :
A ← 1 A = 1 B = ?
B ← A + 3 A = 1 B = 4
A ← 3 A = 3 B = 4
Exercice 1.2
Après La valeur des variables est :
A ← 5 A = 5 B = ? C = ?
B ← 3 A = 5 B = 3 C = ?
C ← A + B A = 5 B = 3 C = 8
A ← 2 A = 2 B = 3 C = 8
C ← B – A A = 2 B = 3 C = 1
Exercice 1.3
Après La valeur des variables est :
A ← 5 A = 5 B = ?
B ← A + 4 A = 5 B = 9
A ← A + 1 A = 6 B = 9
B ← A – 4 A = 6 B = 2
Exercice 1.4
Après La valeur des variables est :
A ← 3 A = 3 B = ? C = ?
B ← 10 A = 3 B = 10 C = ?
C ← A + B A = 3 B = 10 C = 13
B ← A + B A = 3 B = 13 C = 13
A ← C A = 13 B = 13 C = 13
Exercice 1.5
Après La valeur des variables est :
A ← 5 A = 5 B = ?
B ← 2 A = 5 B = 2
A ← B A = 2 B = 2
B ← A A = 2 B = 2
Les deux dernières instructions ne permettent donc pas d’échanger les deux valeurs de B et A, puisque l’une des deux valeurs (celle de A) est ici écrasée.
Si l’on inverse les deux dernières instructions, cela ne changera rien du tout, hormis le fait que cette fois c’est la valeur de B qui sera écrasée.
Exercice 1.6
Début
…
C ← A
A ← B
B ← C
Fin
On est obligé de passer par une variable dite temporaire (la variable C).
Exercice 1.7
Début
…
D ← C
C ← B
B ← A
A ← D
Fin
En fait, quel que soit le nombre de variables, une seule variable temporaire suffit…
Exercice 1.8
Il ne peut produire qu’une erreur d’exécution, puisqu’on ne peut pas additionner des caractères.
Exercice 1.9
…En revanche, on peut les concaténer. A la fin de l’algorithme, C vaudra donc "42312".

Exercice 2.1
On verra apparaître à l’écran 231, puis 462 (qui vaut 231 * 2)
Exercice 2.2
Variables nb, carr en Entier
Début
Ecrire "Entrez un nombre :"
Lire nb
carr ← nb * nb
Ecrire "Son carré est : ", carr
Fin
En fait, on pourrait tout aussi bien économiser la variable carr en remplaçant les deux avant-dernières lignes par :
Ecrire "Son carré est : ", nb*nb
C'est une question de style ; dans un cas, on privilégie la lisibilité de l'algorithme, dans l'autre, on privilégie l'économie d'une variable.
Exercice 2.3
Variables nb, pht, ttva, pttc en Numérique
Début
Ecrire "Entrez le prix hors taxes :"
Lire pht
Ecrire "Entrez le nombre d’articles :"
Lire nb
Ecrire "Entrez le taux de TVA :"
Lire ttva
pttc ← nb * pht * (1 + ttva)
Ecrire "Le prix toutes taxes est : ", pttc
Fin
Là aussi, on pourrait squeezer une variable et une ligne en écrivant directement. :
Ecrire "Le prix toutes taxes est : ", nb * pht * (1 + ttva)
C'est plus rapide, plus léger en mémoire, mais un peu plus difficile à relire (et à écrire !)
Exercice 2.4
Variables t1, t2, t3, t4 en Caractère
Début
t1 ← "belle Marquise"
t2 ← "vos beaux yeux"
t3 ← "me font mourir"
t4 ← "d’amour"
Ecrire t1 & " " & t2 & " " & t3 & " " & t4
Ecrire t3 & " " & t2 & " " & t4 & " " & t1
Ecrire t2 & " " & t3 & " " & t1 & " " & t4
Ecrire t4 & " " & t1 & " " & t2 & " " & t3
Fin
Exercice 3.2
Variables m, n en Entier
Début
Ecrire "Entrez deux nombres : "
Lire m, n
Si (m > 0 ET n > 0) OU (m < 0 ET n < 0) Alors
 Ecrire "Leur produit est positif"
Sinon
 Ecrire "Leur produit est négatif"
Finsi
Fin
Exercice 3.3
Variables a, b, c en Caractère
Début
Ecrire "Entrez successivement trois noms : "
Lire a, b, c
Si a < b ET b < c Alors
 Ecrire "Ces noms sont classés alphabétiquement"
Sinon
 Ecrire "Ces noms ne sont pas classés"
Finsi
Fin
Exercice 3.4
Variable n en Entier
Début
Ecrire "Entrez un nombre : "
Lire n
Si n < 0 Alors
 Ecrire "Ce nombre est négatif"
SinonSi n = 0 Alors
 Ecrire "Ce nombre est nul"
Sinon
 Ecrire "Ce nombre est positif"
Finsi
Fin
Exercice 3.5
Variables m, n en Entier
Début
Ecrire "Entrez deux nombres : "
Lire m, n
Si m = 0 OU n = 0 Alors
 Ecrire "Le produit est nul"
SinonSi (m < 0 ET n < 0) OU (m > 0 ET n > 0) Alors
 Ecrire "Le produit est positif"
Sinon
 Ecrire "Le produit est négatif"
Finsi
Fin
Si on souhaite simplifier l’écriture de la condition lourde du SinonSi, on peut toujours passer par des variables booléennes intermédiaires. Une astuce de sioux consiste également à employer un Xor (c'est l'un des rares cas dans lesquels il est pertinent)
Exercice 3.6
Variable age en Entier
Début
Ecrire "Entrez l’âge de l’enfant : "
Lire age
Si age >= 12 Alors
 Ecrire "Catégorie Cadet"
SinonSi age >= 10 Alors
 Ecrire "Catégorie Minime"
SinonSi age >= 8 Alors
 Ecrire "Catégorie Pupille"
SinonSi age >= 6 Alors
 Ecrire "Catégorie Poussin"
Finsi
Fin
Exercice 4.1
Aucune difficulté, il suffit d’appliquer la règle de la transformation du OU en ET vue en cours (loi de Morgan). Attention toutefois à la rigueur dans la transformation des conditions en leur contraire...
Si Tutu <= Toto + 4 ET Tata <> "OK" Alors
 Tutu ← Tutu - 1
Sinon
 Tutu ← Tutu + 1
Finsi
Exercice 4.2
Variables h, m en Numérique
Début
Ecrire "Entrez les heures, puis les minutes : "
Lire h, m
m ← m + 1
Si m = 60 Alors
 m ← 0
 h ← h + 1
FinSi
Si h = 24 Alors
 h ← 0
FinSi
Ecrire "Dans une minute il sera ", h, "heure(s) ", m, "minute(s)"
Fin
Exercice 4.3
Variables h, m, s en Numérique
Début
Ecrire "Entrez les heures, puis les minutes, puis les secondes : "
Lire h, m, s
s ← s + 1
Si s = 60 Alors
 s ← 0
 m ← m + 1
FinSi
Si m = 60 Alors
 m ← 0
 h ← h + 1
FinSi
Si h = 24 Alors
 h ← 0
FinSi
Ecrire "Dans une seconde il sera ", h, "h", m, "m et ", s, "s"
Fin
Exercice 4.4
Variables n, p en Numérique
Début
Ecrire "Nombre de photocopies : "
Lire n
Si n <= 10 Alors
 p ← n * 0,1
SinonSi n <= 30 Alors
 p ← 10 * 0,1 + (n – 10) * 0,09
Sinon
 p ← 10 * 0,1 + 20 * 0,09 + (n – 30) * 0,08
FinSi
Ecrire "Le prix total est: ", p
Fin
Exercice 4.5
Variable sex en Caractère
Variable age en Numérique
Variables C1, C2 en Booléen
Début
Ecrire "Entrez le sexe (M/F) : "
Lire sex
Ecrire "Entrez l’âge: "
Lire age
C1 ← sex = "M" ET age > 20
C2 ← sex = "F" ET (age > 18 ET age < 35)
Si C1 ou C2 Alors
 Ecrire "Imposable"
Sinon
 Ecrire "Non Imposable"
FinSi
Fin
Exercice 4.6
Cet exercice, du pur point de vue algorithmique, n'est pas très méchant. En revanche, il représente dignement la catégorie des énoncés piégés.
En effet, rien de plus facile que d'écrire : si le candidat a plus de 50%, il est élu, sinon s'il a plus de 12,5 %, il est au deuxième tour, sinon il est éliminé. Hé hé hé... mais il ne faut pas oublier que le candidat peut très bien avoir eu 20 % mais être tout de même éliminé, tout simplement parce que l'un des autres a fait plus de 50 % et donc qu'il n'y a pas de deuxième tour !...
Moralité : ne jamais se jeter sur la programmation avant d'avoir soigneusement mené l'analyse du problème à traiter.
Variables A, B, C, D en Numérique
Variables C1, C2, C3, C4 en Booléen
Début
Ecrire "Entrez les scores des quatre prétendants :"
Lire A, B, C, D
C1 ← A > 50
C2 ← B > 50 ou C > 50 ou D > 50
C3 ← A >= B et A >= C et A >= D
C4 ← A >= 12,5
Si C1 Alors
 Ecrire “Elu au premier tour"
Sinonsi C2 ou Non(C4) Alors
 Ecrire “Battu, éliminé, sorti !!!”
SinonSi C3 Alors
 Ecrire "Ballotage favorable"
Sinon
 Ecrire "Ballotage défavorable"
FinSi
Fin

Exercice 4.7
Là encore, on illustre l'utilité d'une bonne analyse. Je propose deux corrigés différents. Le premier suit l'énoncé pas à pas. C'est juste, mais c'est vraiment lourd. La deuxième version s'appuie sur une vraie compréhension d'une situation pas si embrouillée qu'elle n'en a l'air.  Dans les deux cas, un recours aux variables booléennes aère sérieusement l'écriture.
 Donc, premier corrigé, on suit le texte de l'énoncé pas à pas :
Variables age, perm, acc, assur en Numérique
Variables C1, C2, C3 en Booléen
Variable situ en Caractère
Début
Ecrire "Entrez l’âge: "
Lire age
Ecrire "Entrez le nombre d'années de permis: "
Lire perm
Ecrire "Entrez le nombre d'accidents: "
Lire acc
Ecrire "Entrez le nombre d'années d'assurance: "
Lire assur
C1 ← age >= 25
C2 ← perm >= 2
C3 ← assur > 5
Si Non(C1) et Non(C2) Alors
 Si acc = 0 Alors
 situ ← "Rouge"
 Sinon
 situ ← "Refusé"
 FinSi
Sinonsi ((Non(C1) et C2) ou (C1 et Non(C2)) Alors
 Si acc = 0 Alors
 situ ← "Orange"
 SinonSi acc = 1 Alors
 situ ← "Rouge"
 Sinon
 situ ← "Refusé"
 FinSi
Sinon
 Si acc = 0 Alors
 situ ← "Vert"
 SinonSi acc = 1 Alors
 situ ← "Orange"
 SinonSi acc = 2 Alors
 situ ← "Rouge"
 Sinon
 situ ← "Refusé"
 FinSi
FinSi
Si C3 Alors
 Si situ = "Rouge" Alors
 situ ← "Orange"
 SinonSi situ = "Orange" Alors
 situ ← "Orange"
 SinonSi situ = "Vert" Alors
 situ ← "Bleu"
 FinSi
FinSi
Ecrire "Votre situation : ", situ
Fin
Vous trouvez cela compliqué ? Oh, certes oui, ça l'est ! Et d'autant plus qu'en lisant entre les lignes, on pouvait s'apercevoir que ce galimatias de tarifs recouvre en fait une logique très simple : un système à points. Et il suffit de comptabiliser les points pour que tout s'éclaire... Reprenons juste après l'affectation des trois variables booléennes C1, C2, et C3. On écrit :
P ← 0
Si Non(C1) Alors
 P ← P + 1
FinSi
Si Non(C2) Alors
 P ← P + 1
FinSi
P ← P + acc
Si P < 3 et C3 Alors
 P ← P - 1
FinSi
Si P = -1 Alors
 situ ← "Bleu"
SinonSi P = 0 Alors
 situ ← "Vert"
SinonSi P = 1 Alors
 situ ← "Orange"
SinonSi P = 2 Alors
 situ ← "Rouge"
Sinon
 situ ← "Refusé"
FinSi
Ecrire "Votre situation : ", situ
Fin
Exercice 4.8
En ce qui concerne le début de cet algorithme, il n’y a aucune difficulté. C’est de la saisie bête et même pas méchante:
Variables J, M, A, JMax en Numérique
Variables VJ, VM, B en Booleen
Début
Ecrire "Entrez le numéro du jour"
Lire J
Ecrire "Entrez le numéro du mois"
Lire M
Ecrire "Entrez l'année"
Lire A
C'est évidemment ensuite que les ennuis commencent… La première manière d'aborder la chose consiste à se dire que fondamentalement, la structure logique de ce problème est très simple. Si nous créons deux variables booléennes VJ et VM, représentant respectivement la validité du jour et du mois entrés, la fin de l'algorithme sera d'une simplicité biblique (l’année est valide par définition, si on évacue le débat byzantin concernant l’existence de l’année zéro) :
Si VJ et VM alors
 Ecrire "La date est valide"
Sinon
 Ecrire "La date n'est pas valide"
FinSi
Toute la difficulté consiste à affecter correctement les variables VJ et VM, selon les valeurs des variables J, M et A. Dans l'absolu, VJ et VM pourraient être les objets d'une affectation monstrueuse, avec des conditions atrocement composées. Mais franchement, écrire ces conditions en une seule fois est un travail de bénédictin sans grand intérêt. Pour éviter d'en arriver à une telle extrémité, on peut sérier la difficulté en créant deux variables supplémentaires : B : variable booléenne qui indique s'il s'agit d'une année bissextile
JMax : variable numérique qui indiquera le dernier jour valable pour le mois entré.
Avec tout cela, on peut y aller et en ressortir vivant.
On commence par initialiser nos variables booléennes, puis on traite les années, puis les mois, puis les jours.
On note "dp" la condition "divisible par" :
B ← A dp 400 ou (non(A dp 100) et A dp 4)
Jmax ← 0
VM ← M >= 1 et M =< 12
Si VM Alors
 Si M = 2 et B Alors
 JMax ← 29
 SinonSi M = 2 Alors
 JMax ← 28
 SinonSi M = 4 ou M = 6 ou M = 9 ou M = 11 Alors
 JMax ← 30
 Sinon
 JMax ← 31
 FinSi
 VJ ← J >= 1 et J =< Jmax
FinSi
Cette solution a le mérite de ne pas trop compliquer la structure des tests, et notamment de ne pas répéter l'écriture finale à l'écran. Les variables booléennes intermédiaires nous épargnent des conditions composées trop lourdes, mais celles-ci restent néanmoins sérieuses. Une approche différente consisterait à limiter les conditions composées, quitte à le payer par une structure beaucoup plus exigeante de tests imbriqués. Là encore, on évite de jouer les extrémistes et l'on s'autorise quelques conditions composées lorsque cela nous simplifie l'existence. On pourrait aussi dire que la solution précédente "part de la fin" du problème (la date est-elle valide ou non ?), alors que celle qui suit "part du début" (quelles sont les données entrées au clavier ?) :
Si M < 1 ou M > 12 Alors
 Ecrire "Date Invalide"
SinonSi M = 2 Alors
 Si A dp 400 Alors
 Si J < 1 ou J > 29 Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
 SinonSi A dp 100 Alors
 Si J < 1 ou J > 28 Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
 SinonSi A dp 4 Alors
 Si J < 1 ou J > 29Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
 Sinon
 Si J < 1 ou J > 28 Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
 FinSi
SinonSi M = 4 ou M = 6 ou M = 9 ou M = 11 Alors
 Si J < 1 ou J > 30 Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
Sinon
 Si J < 1 ou J > 31 Alors
 Ecrire "Date Invalide"
 Sinon
 Ecrire "Date Valide"
 FinSi
FinSi
On voit que dans ce cas, l'alternative finale (Date valide ou invalide) se trouve répétée un grand nombre de fois. Ce n'est en soi ni une bonne, ni une mauvaise chose. C'est simplement une question de choix stylistique. Personnellement, j'avoue préférer assez nettement la première solution, qui fait ressortir beaucoup plus clairement la structure logique du problème (il n'y a qu'une seule alternative, autant que cette alternative ne soit écrite qu'une seule fois). Il convient enfin de citer une solution très simple et élégante, un peu plus difficile peut-être à imaginer du premier coup, mais qui avec le recul apparaît comme très immédiate. Sur le fond, cela consiste à dire qu'il y a quatre cas pour qu'une date soit valide : celui d'un jour compris entre 1 et 31 dans un mois à 31 jours, celui d'un jour compris entre 1 et 30 dans un mois à 30 jours, celui d'un jour compris entre 1 et 29 en février d'une année bissextile, et celui d'un jour de février compris entre 1 et 28. Ainsi :
B ← (A dp 4 et Non(A dp 100)) ou A dp 400
K1 ← (m=1 ou m=3 ou m=5 ou m=7 ou m=8 ou m=10 ou m=12) et (J>=1 et J=<31)
K2 ← (m=4 ou m=6 ou m=9 ou m=11) et (J>=1 et J=<30)
K3 ← m=2 et B et J>=1 et J=<29
K4 ← m=2 et J>=1 et J=<28
Si K1 ou K2 ou K3 ou K4 Alors
 Ecrire "Date valide"
Sinon
 Ecrire "Date non valide"
FinSi
Fin
Tout est alors réglé avec quelques variables booléennes et quelques conditions composées, en un minimum de lignes de code. La morale de ce long exercice - et non moins long corrigé, c'est qu'un problème de test un peu compliqué admet une pléiade de solutions justes......Mais que certaines sont plus astucieuses que d'autres !

Exercice 5.1
Variable N en Entier
Debut
N ← 0
Ecrire "Entrez un nombre entre 1 et 3"
TantQue N < 1 ou N > 3
 Lire N
 Si N < 1 ou N > 3 Alors
 Ecrire "Saisie erronée. Recommencez”
 FinSi
 FinTantQue
Fin
Exercice 5.2
Variable N en Entier
Debut
N ← 0
Ecrire "Entrez un nombre entre 10 et 20"
TantQue N < 10 ou N > 20
 Lire N
 Si N < 10 Alors
 Ecrire "Plus grand !"
 SinonSi N > 20 Alors
 Ecrire "Plus petit !"
 FinSi
FinTantQue
Fin
Exercice 5.3
Variables N, i en Entier
Debut
Ecrire "Entrez un nombre : "
Lire N
Ecrire "Les 10 nombres suivants sont : "
Pour i ← N + 1 à N + 10
 Ecrire i
i Suivant
Fin
Exercice 5.4
Variables N, i en Entier
Debut
Ecrire "Entrez un nombre : "
Lire N
Ecrire "La table de multiplication de ce nombre est : "
Pour i ← 1 à 10
 Ecrire N, " x ", i, " = ", n*i
i Suivant
Fin

Exercice 5.5
Variables N, i, Som en Entier
Debut
Ecrire "Entrez un nombre : "
Lire N
Som ← 0
Pour i ← 1 à N
 Som ← Som + i
i Suivant
Ecrire "La somme est : ", Som
Fin
Exercice 5.6
Variables N, i, F en Entier
Debut
Ecrire "Entrez un nombre : "
Lire N
F ← 1
Pour i ← 2 à N
 F ← F * i
i Suivant
Ecrire "La factorielle est : ", F
Fin
Exercice 5.7
Variables N, i, PG en Entier
Debut
PG ← 0
Pour i ← 1 à 20
 Ecrire "Entrez un nombre : "
 Lire N
 Si i = 1 ou N > PG Alors
 PG ← N
 FinSi
i Suivant
Ecrire "Le nombre le plus grand était : ", PG
Fin
En ligne 3, on peut mettre n’importe quoi dans PG, il suffit que cette variable soit affectée pour que le premier passage en ligne 7 ne provoque pas d'erreur.
Pour la version améliorée, cela donne :
Variables N, i, PG, IPG en Entier
Debut
PG ← 0
Pour i ← 1 à 20
 Ecrire "Entrez un nombre : "
 Lire N
 Si i = 1 ou N > PG Alors
 PG ← N
 IPG ← i
 FinSi
i Suivant
Ecrire "Le nombre le plus grand était : ", PG
Ecrire "Il a été saisi en position numéro ", IPG
Fin
Exercice 5.8
Variables N, i, PG, IPG en Entier
Debut
N ← 1
i ← 0
PG ← 0 
TantQue N <> 0
 Ecrire "Entrez un nombre : "
 Lire N
 i ← i + 1
 Si i = 1 ou N > PG Alors
 PG ← N
 IPG ← i
 FinSi
FinTantQue
Ecrire "Le nombre le plus grand était : ", PG
Ecrire "Il a été saisi en position numéro ", IPG
Fin
Exercice 5.9
Variables E, somdue, M, Reste, Nb10E, Nb5E En Entier
Debut
E ← 1
somdue ← 0
TantQue E <> 0
 Ecrire "Entrez le montant : "
 Lire E
 somdue ← somdue + E
FinTantQue
Ecrire "Vous devez :", somdue, " euros"
Ecrire "Montant versé :"
Lire M
Reste ← M - somdue
Nb10E ← 0
TantQue Reste >= 10
 Nb10E ← Nb10E + 1
 Reste ← Reste – 10
FinTantQue
Nb5E ← 0
Si Reste >= 5
 Nb5E ← 1
 Reste ← Reste – 5
FinSi
Ecrire "Rendu de la monnaie :"
Ecrire "Billets de 10 E : ", Nb10E
Ecrire "Billets de 5 E : ", Nb5E
Ecrire "Pièces de 1 E : ", reste
Fin
Exercice 5.10
Spontanément, on est tenté d'écrire l'algorithme suivant :
Variables N, P, i, Numé, Déno1, Déno2 en Entier
Debut Ecrire "Entrez le nombre de chevaux partants : "
Lire N
Ecrire "Entrez le nombre de chevaux joués : "
Lire P
Numé ← 1
Pour i ← 2 à N
 Numé ← Numé * i
i Suivant
Déno1 ← 1
Pour i ← 2 à N-P
 Déno1 ← Déno1 * i
i Suivant
Déno2 ← 1
Pour i ← 2 à P
 Déno2 ← Déno2 * i
i Suivant
Ecrire "Dans l’ordre, une chance sur ", Numé / Déno1
Ecrire "Dans le désordre, une sur ", Numé / (Déno1 * Déno2)
Fin
Cette version, formellement juste, comporte tout de même deux faiblesses.
La première, et la plus grave, concerne la manière dont elle calcule le résultat final. Celui-ci est le quotient d'un nombre par un autre ; or, ces nombres auront rapidement tendance à être très grands. En calculant, comme on le fait ici, d'abord le numérateur, puis ensuite le dénominateur, on prend le risque de demander à la machine de stocker des nombres trop grands pour qu'elle soit capable de les coder (cf. le préambule). C'est d'autant plus bête que rien ne nous oblige à procéder ainsi : on n'est pas obligé de passer par la division de deux très grands nombres pour obtenir le résultat voulu.
La deuxième remarque est qu'on a programmé ici trois boucles successives. Or, en y regardant bien, on peut voir qu'après simplification de la formule, ces trois boucles comportent le même nombre de tours ! (si vous ne me croyez pas, écrivez un exemple de calcul et biffez les nombres identiques au numérateur et au dénominateur). Ce triple calcul (ces trois boucles) peut donc être ramené(es) à un(e) seul(e). Et voilà le travail, qui est non seulement bien plus court, mais aussi plus performant :
Variables N, P, i, A, B en Numérique
Debut
Ecrire "Entrez le nombre de chevaux partants : "
Lire N
Ecrire "Entrez le nombre de chevaux joués : " 
Lire P 
A ← 1 
B ← 1 
Pour i ← 1 à P 
 A ← A * (i + N - P) 
 B ← B * i 
i Suivant 
Ecrire "Dans l’ordre, une chance sur ", A 
Ecrire "Dans le désordre, une chance sur ", A / B 
Fin

Exercice 6.1
Tableau Truc(6) en Numérique
Variable i en Numérique
Debut
Pour i ← 0 à 6
 Truc(i) ← 0
i Suivant
Fin
Exercice 6.2
Tableau Truc(5) en Caractère
Debut
Truc(0) ← "a"
Truc(1) ← "e"
Truc(2) ← "i"
Truc(3) ← "o"
Truc(4) ← "u"
Truc(5) ← "y"
Fin
Exercice 6.3
Tableau Notes(8) en Numérique
Variable i en Numérique
Pour i ← 0 à 8
 Ecrire "Entrez la note numéro ", i + 1
 Lire Notes(i)
i Suivant
Fin
Exercice 6.4
Cet algorithme remplit un tableau avec six valeurs : 0, 1, 4, 9, 16, 25. 
Il les écrit ensuite à l’écran. Simplification :
Tableau Nb(5) en Numérique
Variable i en Numérique
Début
Pour i ← 0 à 5
 Nb(i) ← i * i
 Ecrire Nb(i)
i Suivant
Fin
Exercice 6.5
Cet algorithme remplit un tableau avec les sept valeurs : 1, 3, 5, 7, 9, 11, 13. 
Il les écrit ensuite à l’écran. Simplification :
Tableau N(6) en Numérique
Variables i, k en Numérique
Début
N(0) ← 1
Ecrire N(0)
Pour k ← 1 à 6
 N(k) ← N(k-1) + 2
 Ecrire N(k)
k Suivant
Fin
Exercice 6.6
Cet algorithme remplit un tableau de 8 valeurs : 1, 1, 2, 3, 5, 8, 13, 21
Exercice 6.7
Variable S en Numérique
Tableau Notes(8) en Numérique
Debut
s ← 0
Pour i ← 0 à 8
 Ecrire "Entrez la note n° ", i + 1
 Lire Notes(i)
 s ← s + Notes(i)
i Suivant
Ecrire "Moyenne :", s/9
Fin

Exercice 6.8
Variables Nb, Nbpos, Nbneg en Numérique
Tableau T() en Numérique
Debut
Ecrire "Entrez le nombre de valeurs :"
Lire Nb
Redim T(Nb-1)
Nbpos ← 0
Nbneg ← 0
Pour i ← 0 à Nb - 1
 Ecrire "Entrez le nombre n° ", i + 1
 Lire T(i)
 Si T(i) > 0 alors
 Nbpos ← Nbpos + 1
 Sinon
 Nbneg ← Nbneg + 1
 Finsi
i Suivant
Ecrire "Nombre de valeurs positives : ", Nbpos
Ecrire "Nombre de valeurs négatives : ", Nbneg
Fin
Exercice 6.9
Variables i, Som, N en Numérique
Tableau T() en Numérique
Debut
… (on ne programme pas la saisie du tableau, dont on suppose qu’il compte N éléments)
Redim T(N-1)
…
Som ← 0
Pour i ← 0 à N - 1
 Som ← Som + T(i)
i Suivant
Ecrire "Somme des éléments du tableau : ", Som
Fin
Exercice 6.10
Variables i, N en Numérique
Tableaux T1(), T2(), T3() en Numérique
Debut
… (on suppose que T1 et T2 comptent N éléments, et qu’ils sont déjà saisis)
Redim T3(N-1)
…
Pour i ← 0 à N - 1
 T3(i) ← T1(i) + T2(i)
i Suivant
Fin
Exercice 6.11
Variables i, j, N1, N2, S en Numérique
Tableaux T1(), T2() en Numérique
Debut
… On ne programme pas la saisie des tableaux T1 et T2.
On suppose que T1 possède N1 éléments, et que T2 en possède T2)
…
S ← 0
Pour i ← 0 à N1 – 1
 Pour j ← 0 à N2 – 1
 S ← S + T1(i) * T2(j)
 j Suivant
i Suivant
Ecrire "Le schtroumpf est : ", S
Fin
Exercice 6.12
Variables Nb, i en Numérique
Tableau T() en Numérique
Debut
Ecrire "Entrez le nombre de valeurs : "
Lire Nb
Redim T(Nb-1)
Pour i ← 0 à Nb - 1
 Ecrire "Entrez le nombre n° ", i + 1
 Lire T(i)
i Suivant
Ecrire "Nouveau tableau : "
Pour i ← 0 à Nb – 1
 T(i) ← T(i) + 1
 Ecrire T(i)
i Suivant
Fin
Exercice 6.13
Variables Nb, Posmaxi en Numérique
Tableau T() en Numérique
Ecrire "Entrez le nombre de valeurs :"
Lire Nb
Redim T(Nb-1)
Pour i ← 0 à Nb - 1
 Ecrire "Entrez le nombre n° ", i + 1
 Lire T(i)
i Suivant
Posmaxi ← 0
Pour i ← 0 à Nb - 1
 Si T(i) > T(Posmaxi) alors
 Posmaxi ← i
 Finsi
i Suivant
Ecrire "Element le plus grand : ", T(Posmaxi)
Ecrire "Position de cet élément : ", Posmaxi
Fin
Exercice 6.14
Variables Nb, i, Som, Moy, Nbsup en Numérique
Tableau T() en Numérique
Debut
Ecrire "Entrez le nombre de notes à saisir : "
Lire Nb
Redim T(Nb-1)
Pour i ← 0 à Nb - 1
 Ecrire "Entrez le nombre n° ", i + 1
 Lire T(i)
i Suivant
Som ← 0
Pour i ← 0 à Nb - 1
 Som ← Som + T(i)
i Suivant
Moy ← Som / Nb
NbSup ← 0
Pour i ← 0 à Nb - 1
 Si T(i) > Moy Alors
 NbSup ← NbSup + 1
 FinSi
i Suivant
Ecrire NbSup, " élèves dépassent la moyenne de la classe"
Fin


CORRECTION EN SUPPLEMENT
-- Ex ex_tva
-- Ex ex_puiss
-- Ex ex_jeu
-- Ex ex_moy
-- Ex ex_jeu_bis
-- Ex ex_calc
-- EX moy.a
-- Ex rot.b
-- Ex clas.c
-- Ex str
--Ex mat
-- Ex tel
-- Ex rec
-- Ex fichier
-- Ex pointeurs
-- Ex ex_tva
program tva(input,output);
var prix_unitaire,quantite,
total_ht,tva,total_ttc:real;
begin
writeln('prix de l''article ?');
readln(prix_unitaire);
writeln('quantité désirée ? ');
readln(quantite);
total_ht:=prix_unitaire*quantite;
tva:=total_ht*(18.6/100);
 total_ttc:=total_ht+tva;
writeln('total ht : ',total_ht);
writeln('tva : ',tva);
writeln(' -------------');
writeln('total ttc : ',total_ttc)
end.
-- Ex ex_puiss
program puissances(input,output);
var n,max:integer;
begin
writeln('nombre maxi ? ');
readln(max);
n:=2;
while n<=max do begin
writeln(n);
n:=n*2
end;
writeln('c''est fini')
end.
-- Ex ex_jeu
program jeu(input,output);
var choix,rep,nb:integer;
begin
nb:=0;
choix:=random(11);
repeat
nb:=nb+1;
writeln('choix ndeg. ',nb,' ? ');
readln(rep)
until rep=choix;
writeln('trouvé en ',nb,' coups')
end.
-- Ex ex_moy
program moyenne(input,output);
var n,i:integer;
 note,total,moyenne:real;
begin
writeln('nombre notes à entrer ?');
readln(n);
total:=0;
for i:=1 to n do begin
writeln(i,'ième note ? ');
readln(note);
total:=total+note
end;
moyenne:=total/n;
writeln('la moyenne est : ',moyenne)
end.
-- Ex ex_jeu_bis
program jeu_ameliore(input,output);
var choix,rep,nb:integer;
begin
nb:=0;
choix:=random(11);
repeat
nb:=nb+1;
writeln('choix ndeg. ',nb,' ? ');
readln(rep);
if rep<choix then
writeln('c''est plus')
else if rep>choix then
writeln('c''est moins')
{le 2ème if empêche d'écrire si juste}
until rep=choix;
writeln('juste en ',nb,' coups')
end.
-- Ex ex_calc
program calculatrice(input,output);
var val1,val2,resultat:real;
operation:char;
begin
writeln('première valeur ?');
readln(val1);
writeln('opération (+ - * /) ? ');
readln(operation)
writeln('deuxième valeur ? ');
readln(val2);
case operation of
 '+':resultat:=val1+val2;
 '-':resultat:=val1-val2;
 '*':resultat:=val1*val2;
 '/':resultat:=val1/val2
end;
writeln('résultat : ',resultat)
end.
-- EX moy.a
program moyenne(input,output);
var n,compteur:integer
somme,moyenne,ecart:real;
note:array[1..100] of real;
begin
repeat
writeln('nb notes (100 maxi)?');
readln(n)
until (n>0) and (n<=100);
{entrée notes et calcul de la somme}
somme:=0;
for compteur:=1 to n do
begin
writeln(compteur,'è note ?');
readln(note[compteur]);
 somme:=somme+note[compteur]
end;
{calcul et affichage de la moyenne}
moyenne:=somme/n;
writeln('moyenne : ',moyenne);
{calcul et affichage des écarts}
writeln('écarts :');
for compteur:=1 to n do
begin
 ecart:=note[compteur]-moyenne;
writeln(compteur,'ième note (',
note[compteur],
 ') : écart : ',ecart)
end
end.
-- Ex rot.b

program rotation(input,output);
var index,n:integer;
prem:real;
tableau:array[1..100]of real;
begin
repeat
writeln('nb valeurs (100 maxi)?');
readln(n)
until (n>0) and (n<=100);
(* entrée des valeurs *)
for index:=1 to n do
begin
writeln(index,'ième valeur ?');
readln(tableau[index]);
end;
writeln('on décale vers le haut');
prem:=tableau[1]; {ne pas écraser!}
for index:=2 to n do
tableau[index-1]:=tableau[index];
tableau[n]:=prem;
for index:=1 to n do
writeln(tableau[index]);
writeln('on re-décale vers le bas');
prem:=tableau[n];
for index:=n downto 2 do
tableau[index]:=tableau[index-1];
tableau[1]:=prem;
for index:=1 to n do
writeln(tableau[index])
end.
-- Ex clas.c
program classer(input,output);
var n,i,index,petit,indexpetit:integer;
avant,apres:array[1..100]of integer;
pris:array[1..100] of boolean; 
 {pour noter ceux déjà pris}
begin
repeat
writeln('nb valeurs (100 maxi) ?');
readln(n)
until (n>0) and (n<=100);
{entrée valeurs - initialisation de pris}
for index:=1 to n do begin
writeln(index,'ième valeur ? ');
readln(avant[index]);
pris[index]:=false
end;
{ordre croissant,on cherche N valeurs}
for i:=1 to n do begin
petit:=maxint; {plus grand possible}
{recherche du plus petit non pris}
for index:=1 to n do
if (not pris[index]) and
(avant[index]<=petit) then begin
 petit:=avant[index];
indexpetit:=index
end;
{ sauvegarde dans le tableau APRES et
 mise à jour de PRIS }
apres[i]:=petit;
pris[indexpetit]:=true
end; { passage au prochain i }
{affichage du tableau APRES}
writeln('par ordre croissant : ');
for i:=1 to N do writeln(apres[i]);
{classement par ordre décroissant}
writeln('par ordre décroissant : ');
for i:=n downto 1 do writeln(apres[i])
{n'auriez-vous pas tout refait ?}
end.
-- Ex str

program position(input,output);
var ch,sch:string[255];
i,j,n,l,ls:integer;
begin
writeln('chaîne à tester ? ');
readln(ch);
writeln('sous-chaîne à trouver ?');
readln(sch);
l:=length(ch);ls:=length(sch);
n:=0;
for i:=1 to l-ls do begin
j:=1;
while (j<=l)and(ch[i+j-1]=sch[j])
do j:=j+1;
if j>ls then begin
writeln('trouvé position ',i);
n:=n+1
end
end;
writeln(n,' fois ',sch,' dans ',ch)
end.
--Ex mat
program produit_mat(input,output);
var m1,m2,m3:array[1..10,1..10]of real;
l,m,n,jl,jm,jn:integer;
begin
writeln('nb lignes 1ère matrice ?');
readln(m);
writeln('nb colonnes 1è matrice ?');
readln(l);
writeln('nb colonnes 2è matrice ?');
readln(n);
(* entrée de m1 *)
writeln('première matrice');
for jm:=1 to m do for jl:=1 to l do
begin
writeln('lig',jm,', col',jl,'?');
readln(m1[jm,jl])
end;
(* entrée de m2 *)
writeln('2ième matrice');
for jl:=1 to l do for jn:=1 to n do
begin
writeln('lig',jl,', col',jn,'?');
readln(m2[jl,jn])
end;
(* calcul du produit *)
for jm:=1 to m do for jn:=1 to n do
begin {calcul composante m,n de m2}
m3[jm,jn]:=0;
for jl:=1 to l do m3[jm,jn]:=
m3[jm,jn]+(m1[jm,jl]*m2[jl,jn]);
end;
(* affichage du résultat *)
writeln('résultat');
for jm:=1 to m do for jn:=1 to n do
writeln('m[',jm,',',jn,']=',
m3[jm,jn])
end.
-- Ex tel
program annuaire(input,output);
(* version simplifiée *)
type ligne=string[40];
typepersonne=record
nom:ligne;
num_tel:ligne
(* integer malheureusement < 32635 *)
end;
var pers:array[1..100]of
typepersonne;
nb,i:1..100;
rep:char;
imprimer:boolean;
texte:ligne;

begin
{on suppose avoir ici les instructions
permettant de lire sur fichier disque
NB et le tableau PERS }
repeat
writeln('recherche suivant : ');
writeln(' N : nom');
writeln(' T : numéro téléphone');
writeln(' Q : quitter le prog');
writeln('quel est votre choix ?');
readln(rep);
if rep<>'Q' then begin
writeln('texte à chercher ? ');
readln(texte)
for i:=1 to nb do with pers[i] do
begin
case rep of
 'N':imprimer:=nom=texte;
'T':imprimer:=num_tel=texte;
end;
if imprimer then begin
writeln('nom : ',nom);
writeln('tel : ',num_tel)
end
end
end
until rep='Q'
end.
-- Ex rec
program determ(input,output);
{ on se limite à 10x10, ce qui fait 7h
de calcul et 6.235.314 appels à DETN }
type tmat=array[1..10,1..10] of real;
var dim:integer; 
 {dimension matrice à calculer}
det:real; {résultat désiré}
mat:tmat; {matrice à calculer}
 appel:real; {nb appels à }

procedure entree;
var lig,col:integer;
begin
writeln('dimension de la matrice ?');
readln(dim); {DIM variable globale}
writeln('entrez les composantes :');
for lig:=1 to dim do begin
writeln('pour la ligne ndeg. ',lig);
for col:=1 to dim do begin
writeln('colonne ',col,' ?');
readln(mat[lig,col])
end
end
end;

procedure sous_mat(mdeb:tmat; var mfin:
tmat; ind,dim:integer);
{on supprime la colonne 1 et la ligne
ind pour avoir la s/mat de dim-1}
var col,lig,l:integer;
begin
l:=0;
for lig:=1 to dim do begin
if lig<>ind then begin 
l:=l+1;
for col:=2 to dim do 
mfin[l,col-1]:=mdeb[lig,col]
end
end
end;

function detn(m:tmat;d:integer):real;
{dét ordre d en fonction ordre d-1}
var result:real;
mprim:tmat; {matrice intermédiaire}
lig,signe:integer;
begin
appel:=appel+1;
if d=1 then detn:=m[1,1] 
(* fin de récursivité *)
else begin
 result:=0;
signe:=-1;
for lig:=1 to d do begin
sous_mat(m,mprim,lig,d);
signe:=-signe;
 {changer de signe à chaque ligne}
result:=result + 
 (signe*m[lig,1]*detn(mprim,d-1))
end;
detn:=result
end
end;

begin (* programme principal *)
entree;
appel:=0;
 det:=detn(mat,dim);
writeln('résultat : ',det);
writeln('nb appels DETN : ',appel)
end.
-- Ex fichier

procedure lirefic;
var i:1..100;
f:file of typepersonne;
(* variables globales :
 NB et le tableau PERS *)
begin
assign(f,'annuaire'); {non standard}
reset(f);
nb:=0;
while not EOF(f) do begin
nb:=nb+1;
read(f,pers[nb)
end;
close(f)
end; 
{à vous de faire la suite}
-- Ex pointeurs

program liste(input,output);
TYPE tpoint=^tval;
tval=record
valeur:integer;
suivant:tpoint
end;
 VAR prem:tpoint; {variable globale}
n:integer;
c:char;

procedure lire;
var precedent,point:tpoint;
i:integer;
{ modifie N et PREM }
begin
write('combien d''éléments?');
readln(n);
new(prem);
write('1ère valeur ? ');
readln(prem^.valeur);
precedent:=prem;
for i:=2 to n do begin
new(point);
write(i,'ième valeur ? ');
readln(point^.valeur);
precedent^.suivant:=point;
precedent:=point
end;
precedent^.suivant:=NIL 
(* le dernier ne pointe sur rien *)
end;

procedure afficher;
var point:tpoint;
i:integer;
begin
point:=prem;
for i:=1 to n do begin
writeln(point^.valeur);
point:=point^.suivant
end
end;

procedure supprimer;
var point,prec:tpoint;
rep:char;
begin
point:=prem;
repeat
write(point^.valeur,' à ôter ?');
readln(rep);
if rep='O' then begin
n:=n-1;
if point<>prem then begin
prec^.suivant:=point^.suivant;
dispose(point);
point:=prec^.suivant 
 (* se préparer pour la suite *)
end
else begin
prem:=prem^.suivant;
dispose(point); 
 (* ancien premier *)
point:=prem
 end
 end
 else begin 
(* pointer sur le suivant *)
prec:=point;
point:=point^.suivant
end
until point=nil
end;

procedure rajouter;
var p1,p2,prec:tpoint;
rep:char;
begin
 p1:=prem;
repeat
write(p1^.valeur,' rajouter un
élément avant (O/N) ? ');
readln(rep);
if rep='O' then begin
n:=n+1;
if p1<>prem then begin
new(p2);
write('valeur ? ');
readln(p2^.valeur);
prec^.suivant:=p2;
 p2^.suivant:=p1;
prec:=p2;
end
else begin
new(p1);
write('valeur ? ');
readln(p1^.valeur);
p1^.suivant:=prem;
prem:=p1
end
end
else begin 
(* pointer sur le suivant *)
prec:=p1;
 p1:=p1^.suivant
end
until p1=nil;
 p1:=prec;
repeat
write('ajouter un élément en fin
de liste (O/N) ? ');
readln(rep);
if rep='O' then begin
n:=n+1;
new(p2);
write('valeur ? ');
readln(p2^.valeur);
 p1^.suivant:=p2;
p2^.suivant:=nil;
 p1:=p2
end
until rep<>'O'
end;

BEGIN {prog principal}
lire;
repeat
writeln('A:afficher, S:supprimer R:rajouter, F:fin');
write('votre choix ? ');
readln(c);
case c of
'A':afficher;
'S':supprimer;
 'R':rajouter
end
until c='F'
end.





